<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>五一计划</title>
    <link href="/2021/04/15/5_1/"/>
    <url>/2021/04/15/5_1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>哈尔滨 长春-》延吉-》沈阳</p></blockquote><p><img src="https://github.com/Clarence-Kong/images/blob/master/5.1/5_1.png" srcset="/img/loading.gif" alt="路线计划图"></p><h1 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h1><p>早上出发到长春 放行李 住一晚 </p><p>预计11点左右到，找宾馆放下行李，先去吃饭，下午净月潭，晚上住下</p><p><a href="https://github.com/Clarence-Kong/images/blob/master/5.1/jingyuetan.png" target="_blank" rel="noopener">净月潭</a></p><p>餐厅推荐： <a href="https://www.amap.com/place/B0FFH62XIK" target="_blank" rel="noopener">钱峰碳缸烧烤（南湖大街总店）4.82</a> <a href="https://www.amap.com/place/B0FFK12PUJ" target="_blank" rel="noopener">刘记光大火锅鸡 （红旗街店）4.71</a></p><h1 id="5-2-延吉-长白山"><a href="#5-2-延吉-长白山" class="headerlink" title="5.2 延吉 长白山"></a>5.2 延吉 长白山</h1><p>延吉-》安图西站</p><p>早上火车到延吉，住两晚</p><p>报团</p><p>餐厅推荐：<a href="https://www.amap.com/place/B0G3F7LK7C" target="_blank" rel="noopener">叁代家啤酒屋 猪蹄拌面 4.43</a></p><h1 id="5-3-沈阳"><a href="#5-3-沈阳" class="headerlink" title="5.3 沈阳"></a>5.3 沈阳</h1><p> 故宫 中街</p><h1 id="5-4-5-5-大连-旅顺"><a href="#5-4-5-5-大连-旅顺" class="headerlink" title="5.4 -5.5  大连 旅顺"></a>5.4 -5.5  大连 旅顺</h1>]]></content>
    
    
    
    <tags>
      
      <tag>计划</tag>
      
      <tag>旅游</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>S-LeetCode</title>
    <link href="/2019/11/16/S-LeetCode/"/>
    <url>/2019/11/16/S-LeetCode/</url>
    
    <content type="html"><![CDATA[<h3 id="7-整数反转-reverse-integer"><a href="#7-整数反转-reverse-integer" class="headerlink" title="7.整数反转-reverse-integer"></a>7.整数反转-reverse-integer</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/* 给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。</span><br><span class="hljs-comment">示例 1:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: 123</span><br><span class="hljs-comment">输出: 321</span><br><span class="hljs-comment"> 示例 2:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: -123</span><br><span class="hljs-comment">输出: -321</span><br><span class="hljs-comment">示例 3:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: 120</span><br><span class="hljs-comment">输出: 21</span><br><span class="hljs-comment">注意:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−231,  231 − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/reverse-integer</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> reverse = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> negative = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (num &lt; <span class="hljs-number">0</span>) &#123;<br>        negative = <span class="hljs-literal">true</span>;<br>        num = <span class="hljs-built_in">Math</span>.abs(num);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        mod = num % <span class="hljs-number">10</span>; <span class="hljs-comment">// mod = 3 // mod = 2 // mod</span><br>        num = <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">10</span>); <span class="hljs-comment">// num = 12 // num = 1</span><br>        result = result * <span class="hljs-number">10</span> + mod; <span class="hljs-comment">// 0 = 0 * 10 + 3 = 0 + 3 = 3 // 3 = 3 * 10 + 2 = 30 + 2 = 32</span><br>    &#125;s<br>    <span class="hljs-keyword">if</span> (result &gt; <span class="hljs-number">2147483647</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (negative) <span class="hljs-keyword">return</span> result * <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="1-两数之和-two-sum"><a href="#1-两数之和-two-sum" class="headerlink" title="1.两数之和-two-sum"></a>1.两数之和-two-sum</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="hljs-comment">所以返回 [0, 1]</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/two-sum</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">target</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> twoSum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums, target</span>) </span>&#123;<span class="hljs-comment">// nums = [2, 7, 11, 15], target = 9</span><br>    <span class="hljs-keyword">const</span> myObject = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">const</span> complement = target - nums[i];<span class="hljs-comment">//complement =7</span><br>        <span class="hljs-keyword">if</span> (myObject.hasOwnProperty(complement)) &#123;<br>            <span class="hljs-keyword">return</span> [myObject[complement], i];<br>        &#125;<br>        myObject[nums[i]] = i;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="9-回文数-palindrome-number"><a href="#9-回文数-palindrome-number" class="headerlink" title="9.回文数-palindrome-number"></a>9.回文数-palindrome-number</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 判断一个整数是否是回文数。回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例 1:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: 121</span><br><span class="hljs-comment">输出: true</span><br><span class="hljs-comment">示例 2:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: -121</span><br><span class="hljs-comment">输出: false</span><br><span class="hljs-comment">解释: 从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br><span class="hljs-comment">示例 3:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: 10</span><br><span class="hljs-comment">输出: false</span><br><span class="hljs-comment">解释: 从右向左读, 为 01 。因此它不是一个回文数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/palindrome-number</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">x</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> isPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">const</span> rev = reverseNum(x);<br>    <span class="hljs-keyword">return</span> x === rev;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reverseNum</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> n = num;<br>    <span class="hljs-keyword">let</span> rev = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> dig;<br>    <span class="hljs-keyword">while</span> (num &gt; <span class="hljs-number">0</span>) &#123;<br>        dig = num % <span class="hljs-number">10</span>;<br>        rev = rev * <span class="hljs-number">10</span> + dig;<br>        num = <span class="hljs-built_in">Math</span>.floor(num / <span class="hljs-number">10</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> rev;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-最长回文子串-longest-palindromic-substring"><a href="#5-最长回文子串-longest-palindromic-substring" class="headerlink" title="5.最长回文子串-longest-palindromic-substring"></a>5.最长回文子串-longest-palindromic-substring</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例 1：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: "babad"</span><br><span class="hljs-comment">输出: "bab"</span><br><span class="hljs-comment">注意: "aba" 也是一个有效答案。</span><br><span class="hljs-comment">示例 2：</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: "cbbd"</span><br><span class="hljs-comment">输出: "bb"</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/longest-palindromic-substring</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">const</span> longestPalindrome = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-string">''</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = s.length; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">let</span> s1 = chk(s, i, i), s2 = chk(s, i, i + <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">if</span> (s1.length &gt; res.length) res = s1<br>        <span class="hljs-keyword">if</span> (s2.length &gt; res.length) res = s2<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">chk</span>(<span class="hljs-params">s, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span> (; i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt; s.length; i--, j++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] !== s[j]) <span class="hljs-keyword">break</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> s.slice(i + <span class="hljs-number">1</span>, j)<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="14-最长公共前缀-longest-common-prefix"><a href="#14-最长公共前缀-longest-common-prefix" class="headerlink" title="14.最长公共前缀-longest-common-prefix"></a>14.最长公共前缀-longest-common-prefix</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 编写一个函数来查找字符串数组中的最长公共前缀。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">如果不存在公共前缀，返回空字符串 ""。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例 1:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: ["flower","flow","flight"]</span><br><span class="hljs-comment">输出: "fl"</span><br><span class="hljs-comment">示例 2:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: ["dog","racecar","car"]</span><br><span class="hljs-comment">输出: ""</span><br><span class="hljs-comment">解释: 输入不存在公共前缀。</span><br><span class="hljs-comment">说明:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">所有输入只包含小写字母 a-z 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/longest-common-prefix</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string[]&#125;</span> <span class="hljs-variable">strs</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">const</span> longestCommonPrefix = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">strs</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> A = strs.concat().sort(),<br>        a1 = A[<span class="hljs-number">0</span>] || <span class="hljs-string">""</span>,<br>        a2 = A[A.length - <span class="hljs-number">1</span>] || <span class="hljs-string">""</span>,<br>        L = a1.length,<br>        i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (i &lt; L &amp;&amp; a1.charAt(i) === a2.charAt(i)) i++;<br>    <span class="hljs-keyword">return</span> a1.substring(<span class="hljs-number">0</span>, i);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="237-删除链表中的节点-delete-node-in-a-linked-list"><a href="#237-删除链表中的节点-delete-node-in-a-linked-list" class="headerlink" title="237.删除链表中的节点-delete-node-in-a-linked-list"></a>237.删除链表中的节点-delete-node-in-a-linked-list</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">现有一个链表 -- head = [4,5,1,9]，它可以表示为:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例 1:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: head = [4,5,1,9], node = 5</span><br><span class="hljs-comment">输出: [4,1,9]</span><br><span class="hljs-comment">解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9.</span><br><span class="hljs-comment">示例 2:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: head = [4,5,1,9], node = 1</span><br><span class="hljs-comment">输出: [4,5,9]</span><br><span class="hljs-comment">解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9.</span><br><span class="hljs-comment"> </span><br><span class="hljs-comment"></span><br><span class="hljs-comment">说明:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">链表至少包含两个节点。</span><br><span class="hljs-comment">链表中所有节点的值都是唯一的。</span><br><span class="hljs-comment">给定的节点为非末尾节点并且一定是链表中的一个有效节点。</span><br><span class="hljs-comment">不要从你的函数中返回任何结果。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/delete-node-in-a-linked-list</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-keyword">const</span> deleteNode = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">node</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (node.next !== <span class="hljs-literal">null</span>) &#123;<br>        node.val = node.next.val;<br>        node.next = node.next.next;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="104-二叉树的最大深度-maximum-depth-of-binary-tree"><a href="#104-二叉树的最大深度-maximum-depth-of-binary-tree" class="headerlink" title="104.二叉树的最大深度-maximum-depth-of-binary-tree"></a>104.二叉树的最大深度-maximum-depth-of-binary-tree</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 给定一个二叉树，找出其最大深度。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">说明: 叶子节点是指没有子节点的节点。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例：</span><br><span class="hljs-comment">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    3</span><br><span class="hljs-comment">   / \</span><br><span class="hljs-comment">  9  20</span><br><span class="hljs-comment">    /  \</span><br><span class="hljs-comment">   15   7</span><br><span class="hljs-comment">返回它的最大深度 3 。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-keyword">const</span> maxDepth = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!root) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">const</span> left = maxDepth(root.left);<br>    <span class="hljs-keyword">const</span> right = maxDepth(root.right);<br>    <span class="hljs-keyword">let</span> depth = left &gt; right ? left : right;<br>    <span class="hljs-keyword">return</span> (depth += <span class="hljs-number">1</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="292-nim-游戏-nim-game"><a href="#292-nim-游戏-nim-game" class="headerlink" title="292.nim 游戏-nim-game"></a>292.nim 游戏-nim-game</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*</span><br><span class="hljs-comment">* 你和你的朋友，两个人一起玩 Nim 游戏：桌子上有一堆石头，每次你们轮流拿掉 1 - 3 块石头。 拿掉最后一块石头的人就是获胜者。你作为先手。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">你们是聪明人，每一步都是最优解。 编写一个函数，来判断你是否可以在给定石头数量的情况下赢得游戏。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">示例:</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">输入: 4</span><br><span class="hljs-comment">输出: false</span><br><span class="hljs-comment">解释: 如果堆中有 4 块石头，那么你永远不会赢得比赛；</span><br><span class="hljs-comment">     因为无论你拿走 1 块、2 块 还是 3 块石头，最后一块石头总是会被你的朋友拿走。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">来源：力扣（LeetCode）</span><br><span class="hljs-comment">链接：https://leetcode-cn.com/problems/nim-game</span><br><span class="hljs-comment">著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。*/</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> canWinNim = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> n % <span class="hljs-number">4</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>算法</tag>
      
      <tag>LeetCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数组，字符串常用方法</title>
    <link href="/2018/12/05/js%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <url>/2018/12/05/js%E6%95%B0%E7%BB%84%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="javascript数组，字符串，math常用方法"><a href="#javascript数组，字符串，math常用方法" class="headerlink" title="javascript数组，字符串，math常用方法"></a>javascript数组，字符串，math常用方法</h1><p>array.filter()过滤函数，返回符合条件的item 不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>];<br> <span class="hljs-keyword">var</span> r = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;<br>     <span class="hljs-built_in">console</span>.log(item); <span class="hljs-comment">// 依次打印'A', 'B', 'C'</span><br>     <span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 依次打印0, 1, 2</span><br>     <span class="hljs-built_in">console</span>.log(self); <span class="hljs-comment">// self就是变量arr</span><br>     <span class="hljs-keyword">return</span> item==<span class="hljs-number">2</span>;<br> &#125;);<br><span class="hljs-comment">// console.log(r)    [2,2]  返回符合条件的所有元素</span><br></code></pre></td></tr></table></figure><p>array.every() 方法用于检测数组所有元素是否都符合指定条件，所有符合返回true，不符合返回false 不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> r = arr.every(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> item&gt;<span class="hljs-number">4</span>;<br>&#125;);<br><span class="hljs-comment">//console.log(r)   false    数组中所有元素都小于4</span><br></code></pre></td></tr></table></figure><p>array.some() 方法用于检测数组中的元素是否满足指定条件，有一个满足就返回true</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <span class="hljs-keyword">var</span> r = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> item&gt;<span class="hljs-number">2</span>;     <span class="hljs-comment">//console.log(r)   由于3满足条件，返回true</span><br> &#125;);<br>array.reduce() 方法接收一个函数作为累加器，累加数组的值。<br><br> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <span class="hljs-keyword">var</span> r = arr.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">total,item, index, self</span>) </span>&#123;  <span class="hljs-comment">//total用来保存累加结果的，初始值为0；</span><br>     <span class="hljs-keyword">return</span> total+item;     <span class="hljs-comment">//  结果返回6</span><br> &#125;);<br></code></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">array.map() 方法按照原始数组元素顺序依次处理元素，可返回新数组，但不会改变原数组<br><br> <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> <span class="hljs-keyword">var</span> r = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;<br>     <span class="hljs-keyword">return</span> item*<span class="hljs-number">2</span>;     <span class="hljs-comment">//1,2,3 循环输出数组所有信息，可在此处理业务逻辑</span><br> &#125;);<br> <span class="hljs-built_in">console</span>.log(r)     <span class="hljs-comment">//[2, 4, 6]  </span><br> <span class="hljs-built_in">console</span>.log(arr)  <span class="hljs-comment">//[1, 2, 3]</span><br></code></pre></td></tr></table></figure><p>array.find() 方法用来返回数组中满足条件的第一个元素 不会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> r = arr.find(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> item&gt;=<span class="hljs-number">2</span>;<br>&#125;);<br><span class="hljs-comment">//console.log(r)   2    返回满足条件的第一个元素</span><br></code></pre></td></tr></table></figure><p>array.forEach() 方法用于调用数组的每个元素，并将元素传递给回调函数，可用于遍历数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item, index, self</span>) </span>&#123;    <span class="hljs-comment">//特别注意forEach返回值为undefined</span><br>     <span class="hljs-built_in">console</span>.log(item);     <span class="hljs-comment">//1,2,3 循环输出数组所有信息，可在此处理业务逻辑</span><br> &#125;);<br></code></pre></td></tr></table></figure><p>for /for…in  遍历数组</p><p> for循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Mango"</span>];<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>,length=arr.length;i&lt;length;i++)&#123;<br><br>        <span class="hljs-built_in">console</span>.log( arr[i]) <span class="hljs-comment">// Banana  Orange  Apple  Mango</span><br><br>     &#125;<br></code></pre></td></tr></table></figure><p>   //遍历出数组的每一项</p><p> for….in: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"Apple"</span>];<br><br> <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> index  <span class="hljs-keyword">in</span> arr)&#123;<br><br><span class="hljs-built_in">console</span>.log(arr[index])<span class="hljs-comment">//Banana  Orange  Apple </span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>array.indexOf(item,start) 方法可返回某个指定的字符串值在字符串中首次出现的位置。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> fruits = [<span class="hljs-string">"Banana"</span>, <span class="hljs-string">"Orange"</span>, <span class="hljs-string">"Apple"</span>, <span class="hljs-string">"Mango"</span>];<br><span class="hljs-keyword">var</span> a = fruits.indexOf(<span class="hljs-string">"Apple"</span>);<span class="hljs-comment">//a=2</span><br></code></pre></td></tr></table></figure><p>array.join(separator)将数组按特定分割符组合成字符串（数组=&gt;字符串）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.join(<span class="hljs-string">''</span>);<span class="hljs-comment">//返回"123"</span><br>arr.join(<span class="hljs-string">'a'</span>);<span class="hljs-comment">//返回"1a2a3" 不改变原数组</span><br></code></pre></td></tr></table></figure><p>array.toString()将数组转为字符串，并以逗号隔开（数组=&gt;字符串）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr= [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];<br><span class="hljs-keyword">var</span> arrstring = arr.toString();<span class="hljs-comment">//arrstring = "a,b,c,d" ，不改变原数组</span><br></code></pre></td></tr></table></figure><p>Array.isArray(obj)判断对象是否是数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">var</span> obj= &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">"cgd"</span>&#125;;<br><span class="hljs-built_in">Array</span>.isArray(arr)   <span class="hljs-comment">//true</span><br><span class="hljs-built_in">Array</span>.isArray(obj)   <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>#数组的堆栈操作 删除操作返回删除元素，添加操作返回新的长度，均会改变原数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];  <span class="hljs-comment">//以下操作单独执行</span><br>arr.pop();          <span class="hljs-comment">//arr 输出为["a", "b", "c"]   删除数组末尾元素</span><br>arr.push(<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>)   <span class="hljs-comment">//arr 输出为["a", "b", "c", "d", "e", "f"]  向数组末尾添加元素</span><br>arr.shift()         <span class="hljs-comment">//arr 输出为["b", "c", "d"]     删除数组第一个元素</span><br>arr.unshift(<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>)        <span class="hljs-comment">//arr 输出为["e","f","a","b", "c", "d"]     向数组开始添加元素</span><br></code></pre></td></tr></table></figure><p>array.concat(arr1)  数组之间连接 arr和arr1连接成一个新的数组,原数组都不变，返回新数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];  <br><br><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>, <span class="hljs-string">"g"</span>, <span class="hljs-string">"h"</span>]; <br><br> <span class="hljs-keyword">var</span>  c=arr.concat(arr1)   <span class="hljs-comment">//["a", "b", "c", "d", "e", "f", "g", "h"]</span><br></code></pre></td></tr></table></figure><p>array.splice(index,howmany,item1,…..,itemX) 方法用于插入、删除或替换数组的元素，这种方法会改变原始数组，很强大 </p><p>  index 表示开始位置,<br>    howmany 表示删除多少个必须为数字，可以为0表示不删除,如果不填的话会从index位置删到最后<br>    item1 表示要添加到数组的新元素</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr= [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];<br>arr.splice(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"e"</span>,<span class="hljs-string">"f"</span>); <span class="hljs-comment">//["a", "b", "e", "f", "d"] 从位置为2的地方删除一个元素并添加两个元</span><br><br> array.slice(index1，index2)   参数index可正可负，包含arr[index1],不包含arr[index2]，原数组都不变，返回截取的新数组<br><br>        <span class="hljs-keyword">var</span> arr=[<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>, <span class="hljs-string">"e"</span>, <span class="hljs-string">"f"</span>, <span class="hljs-string">"g"</span>, <span class="hljs-string">"h"</span>]<br>    <br>        <span class="hljs-keyword">var</span> arrNew=arr.slice(<span class="hljs-number">3</span>,<span class="hljs-number">-1</span>) <span class="hljs-comment">//["d", "e", "f", "g", "h"]</span><br>    <br>       <span class="hljs-keyword">var</span> arrNew=arr.slice(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>)  <span class="hljs-comment">//["b", "c"]</span><br></code></pre></td></tr></table></figure><p>array.reverse() 方法用于颠倒数组中元素的顺序。（元素反转）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>arr.reverse() <span class="hljs-comment">// console.log(arr)   输出[3,2,1]</span><br></code></pre></td></tr></table></figure><p>array.sort(sortfunction)对数组进行排序，没传递函数时，按升序排</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr= [<span class="hljs-number">40</span>,<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">25</span>,<span class="hljs-number">10</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> a-b&#125;); <span class="hljs-comment">//升序排列[1,5,10,25,40,100]</span><br><br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a,b</span>)</span>&#123;<span class="hljs-keyword">return</span> b-a&#125;); <span class="hljs-comment">//降序序排列[100, 40, 25, 10, 5, 1]</span><br></code></pre></td></tr></table></figure><p>拓展：取数组的最大值/最小值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> min = arr[<span class="hljs-number">0</span>]; <span class="hljs-comment">//升序时最小值，逆序时最大值</span><br><br> <span class="hljs-keyword">var</span> max = arr[arr.length - <span class="hljs-number">1</span>]; <span class="hljs-comment">//升序时最大值，逆序时最小值</span><br><br>通过<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, arr);<span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, arr);<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">22</span>,<span class="hljs-number">13</span>,<span class="hljs-number">6</span>,<span class="hljs-number">55</span>,<span class="hljs-number">30</span>];<br><br><span class="hljs-keyword">var</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, arr); <span class="hljs-comment">//最大值</span><br><br><span class="hljs-keyword">var</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, arr);<span class="hljs-comment">//最小值</span><br></code></pre></td></tr></table></figure><p>通过ES6扩展符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs javascript"> arr = [<span class="hljs-number">22</span>,<span class="hljs-number">13</span>,<span class="hljs-number">6</span>,<span class="hljs-number">55</span>,<span class="hljs-number">30</span>]; <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>(...arr));<br><br>array.valueOf() 返回数组的原始值<br><br><span class="hljs-keyword">var</span> arr= [<span class="hljs-string">"a"</span>, <span class="hljs-string">"b"</span>, <span class="hljs-string">"c"</span>, <span class="hljs-string">"d"</span>];<br>arr.valueOf() <span class="hljs-comment">//返回原数组，不改变原数组</span><br>-<br><br> array.fill()  使用一个固定值来填充数组。<br><br><span class="hljs-keyword">var</span> arr=[];<br><br>arr.length=<span class="hljs-number">3</span>;<br><br>arr.fill(<span class="hljs-number">2</span>);<span class="hljs-comment">//[2,2,2]</span><br><br>### 二.字符串的常用方法：<br><br><span class="hljs-keyword">var</span> str = ‘abcd’<br><br>str.charAt(<span class="hljs-number">0</span>); <span class="hljs-comment">//输出下标位置的字符</span><br><br>str.charCodeAt(<span class="hljs-number">0</span>);<span class="hljs-comment">//输出下标位置的字符编码值</span><br><br>str.concat(‘e’); <span class="hljs-comment">//输出拼接后的字符串</span><br><br>str.indexOf(‘c’); <span class="hljs-comment">//输出指定字符的下标位置</span><br><br>str.lastIndexOf(‘c’); <span class="hljs-comment">//从后向前搜索输出指定字符的下标位置</span><br><br>str.length; <span class="hljs-comment">//输出字符串长度</span><br><br>str.localeCompare(‘efg’); <span class="hljs-comment">//按照字母表顺序规则比较，输出比较结果，靠前输出1，靠后输出-1，相等输出0</span><br><br>str.search(‘a’); <span class="hljs-comment">//输出指定字符的下标位置</span><br><br>str.slice(<span class="hljs-number">1</span>,<span class="hljs-number">5</span>); <span class="hljs-comment">//输出指定开始下标到结束下标的字符，但不包括结束位置的字符</span><br><br>str.split(‘c’); <span class="hljs-comment">//输出字符串以指定字符分割为数组</span><br><br>str.substr(<span class="hljs-number">0</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">//输出指定下标后面指长度的字符</span><br><br>str.substring(<span class="hljs-number">0</span>); <span class="hljs-comment">//如果没有指定结束位置下标，将输出指定开始下标到最后下标的字符</span><br><br>str.substring(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">//输出指定开始下标到结束下标的字符，但不包括结束位置的字符。如果参数为负数，自动转换参数为0。如果第二个参数小于第一个参数，自动调换参数位置</span><br><br>str.toLowerCase(); <span class="hljs-comment">//输出转换为小写字母的字符</span><br><br>str.toString(); <span class="hljs-comment">//把其他类型的数据输出为字符串类型的数据</span><br><br>str.toUpperCase(); <span class="hljs-comment">//输出转换为大写字母的字符</span><br><br><span class="hljs-built_in">String</span>.fromCharCode(<span class="hljs-number">10000</span>); <span class="hljs-comment">//把Unicode编码转换成对应的文字</span><br><br>str.trim();<span class="hljs-comment">//去掉字符串的首位空格</span><br></code></pre></td></tr></table></figure><h3 id="三-Math的常用方法："><a href="#三-Math的常用方法：" class="headerlink" title="三.Math的常用方法："></a>三.Math的常用方法：</h3><pre><code class="javascript"><span class="built_in">Math</span>.abs()：绝对值              <span class="built_in">Math</span>.abs(<span class="number">1</span>) <span class="comment">// 1            Math.abs(-1) // 1</span><span class="built_in">Math</span>.ceil()：向上取整      <span class="built_in">Math</span>.ceil(<span class="number">3.2</span>) <span class="comment">// 4         Math.ceil(-3.2) // -3</span><span class="built_in">Math</span>.floor()：向下取整    <span class="built_in">Math</span>.floor(<span class="number">3.2</span>) <span class="comment">// 3            Math.floor(-3.2) // -4</span><span class="built_in">Math</span>.max()：最大值         <span class="built_in">Math</span>.max(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// 5    </span><span class="built_in">Math</span>.min()：最小值         <span class="built_in">Math</span>.min(<span class="number">2</span>, <span class="number">-1</span>, <span class="number">5</span>) <span class="comment">// -1</span><span class="built_in">Math</span>.pow()：指数运算     <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// 8  2³=8</span><span class="built_in">Math</span>.sqrt()：平方根      <span class="built_in">Math</span>.sqrt(<span class="number">4</span>) <span class="comment">// 2    Math.sqrt(-4) // NaN</span><span class="built_in">Math</span>.log()：自然对数    <span class="built_in">Math</span>.log(<span class="built_in">Math</span>.E) <span class="comment">// 1     Math.log(10) // 2.302585092994046</span><span class="built_in">Math</span>.exp()：e的指数    <span class="built_in">Math</span>.exp(<span class="number">1</span>) <span class="comment">// 2.718281828459045  e²=7.38905609893065</span><span class="built_in">Math</span>.round()：四舍五入  <span class="built_in">Math</span>.random()：随机数 范围[<span class="number">0</span>,<span class="number">1</span>)   <span class="built_in">Math</span>.random() <span class="comment">// 0.7151307314634323  </span></code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js算法-递归</title>
    <link href="/2018/11/08/js%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/"/>
    <url>/2018/11/08/js%E7%AE%97%E6%B3%95-%E9%80%92%E5%BD%92/</url>
    
    <content type="html"><![CDATA[<h1 id="js算法-递归"><a href="#js算法-递归" class="headerlink" title="js算法-递归"></a>js算法-递归</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><blockquote><ol><li>排序算法博大精深，前辈们用了数年甚至一辈子的心血研究出来的算法，值得我们学习与推敲。</li></ol></blockquote><h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2. 定义"></a>2. 定义</h2><ul><li>方法或函数调用自身的方式称为递归调用，调用称为递，返回称为归。 简单来说就是：<strong>自己调用自己</strong>。</li></ul><p>现实例子：周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊 ？电影院里面太黑了，看不清，没法数，现在你怎么办 ？</p><p>于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。 但是，前面的人也看不清啊，所以他也问他前面的人。 就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。 直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p><p>基本上，所有的递归问题都可以用递推公式来表示，比如:</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">f(n) = f(n<span class="hljs-number">-1</span>) + <span class="hljs-number">1</span>; <br><span class="hljs-comment">// 其中，f(1) = 1</span><br></code></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1) = 1 表示第一排的人知道自己在第一排。</p><p>有了这个递推公式，我们就可以很轻松地将它改为递归代码，如下：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(n) &#123;<br>  if (n == 1) <span class="hljs-keyword">return</span> <span class="hljs-type">1</span>;<br>  <span class="hljs-keyword">return</span> f(n-<span class="hljs-number">1</span>) + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-为什么使用递归-？递归的优缺点-？"><a href="#3-为什么使用递归-？递归的优缺点-？" class="headerlink" title="3. 为什么使用递归 ？递归的优缺点 ？"></a>3. 为什么使用递归 ？递归的优缺点 ？</h2><ul><li>优点：代码的表达力很强，写起来简洁。</li><li>缺点：空间复杂度高、有堆栈溢出风险、存在重复计算、过多的函数调用会耗时较多等问题。</li></ul><h2 id="4-什么样的问题可以用递归解决呢-？"><a href="#4-什么样的问题可以用递归解决呢-？" class="headerlink" title="4. 什么样的问题可以用递归解决呢 ？"></a>4. 什么样的问题可以用递归解决呢 ？</h2><p>一个问题只要同时满足以下 3 个条件，就可以用递归来解决。</p><ul><li><ol><li>问题的解可以分解为几个子问题的解。何为子问题 ？就是数据规模更小的问题。 比如，前面讲的电影院的例子，你要知道，<code>自己在哪一排</code>的问题，可以分解为<code>前一排的人在哪一排</code>这样一个子问题。</li></ol></li><li><ol><li>问题与子问题，除了数据规模不同，求解思路完全一样 比如电影院那个例子，你求解<code>自己在哪一排</code>的思路，和前面一排人求解<code>自己在哪一排</code>的思路，是一模一样的。</li></ol></li><li><ol><li>存在递归终止条件 比如电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1) = 1，这就是递归的终止条件。</li></ol></li></ul><h2 id="5-递归常见问题及解决方案"><a href="#5-递归常见问题及解决方案" class="headerlink" title="5. 递归常见问题及解决方案"></a>5. 递归常见问题及解决方案</h2><ul><li><ol><li>警惕堆栈溢出：可以声明一个全局变量来控制递归的深度，从而避免堆栈溢出。</li></ol></li><li><ol><li>警惕重复计算：通过某种数据结构来保存已经求解过的值，从而避免重复计算。</li></ol></li></ul><h2 id="6-如何实现递归-？"><a href="#6-如何实现递归-？" class="headerlink" title="6. 如何实现递归 ？"></a>6. 如何实现递归 ？</h2><p><strong>1. 递归代码编写</strong></p><p>写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。</p><p><strong>2. 递归代码理解</strong></p><p>对于递归代码，若试图想清楚整个递和归的过程，实际上是进入了一个思维误区。</p><p>那该如何理解递归代码呢 ？</p><ul><li>如果一个问题 A 可以分解为若干个子问题 B、C、D，你可以假设子问题 B、C、D 已经解决。</li><li>而且，你只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可，不需要一层层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。</li><li>屏蔽掉递归细节，这样子理解起来就简单多了。</li></ul><p>因此，<strong>理解递归代码，就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</strong></p><h2 id="7-例子"><a href="#7-例子" class="headerlink" title="7. 例子"></a>7. 例子</h2><h4 id="1-一个阶乘的例子："><a href="#1-一个阶乘的例子：" class="headerlink" title="1. 一个阶乘的例子："></a>1. 一个阶乘的例子：</h4><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs dart">function fact(<span class="hljs-built_in">num</span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> &lt;= <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> * fact(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br>fact(<span class="hljs-number">3</span>) <span class="hljs-comment">// 结果为 6</span><br></code></pre></td></tr></table></figure><p>以下代码可导致出错：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var anotherFact = fact<span class="hljs-comment">; </span><br><span class="hljs-attribute">fact</span> = null<span class="hljs-comment">; </span><br>alert(antherFact(<span class="hljs-number">4</span>))<span class="hljs-comment">; //出错</span><br></code></pre></td></tr></table></figure><p>由于 fact 已经不是函数了，所以出错。</p><p><strong>使用 arguments.callee</strong></p><p>arguments.callee 是一个指向正在执行的函数的指针，arguments.callee 返回正在被执行的对现象。 新的函数为：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs dart">function fact(<span class="hljs-built_in">num</span>)&#123; <br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">num</span> &lt;= <span class="hljs-number">1</span>)&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>; <br>    &#125;<span class="hljs-keyword">else</span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">num</span> * arguments.callee(<span class="hljs-built_in">num</span> - <span class="hljs-number">1</span>); <span class="hljs-comment">//此处更改了。 </span><br>    &#125; <br>&#125; <br><span class="hljs-keyword">var</span> anotherFact = fact; <br>fact = <span class="hljs-keyword">null</span>; <br>alert(antherFact(<span class="hljs-number">4</span>)); <span class="hljs-comment">// 结果为 24</span><br></code></pre></td></tr></table></figure><h4 id="2-再看一个多叉树的例子"><a href="#2-再看一个多叉树的例子" class="headerlink" title="2. 再看一个多叉树的例子"></a>2. 再看一个多叉树的例子</h4><p>先看图</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-cee0e88b39fdaeab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="多叉树"></p><p><strong>叶子结点</strong>：就是深度为 0 的结点，也就是没有孩子结点的结点，简单的说就是一个二叉树任意一个分支上的终端节点。</p><p>数据结构格式，参考如下代码：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs dts">const json = &#123;<br><span class="hljs-symbol">  name:</span> <span class="hljs-string">'A'</span>,<br><span class="hljs-symbol">  children:</span> [<br>    &#123;<br><span class="hljs-symbol">      name:</span> <span class="hljs-string">'B'</span>,<br><span class="hljs-symbol">      children:</span> [<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'E'</span>,<br>        &#125;,<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'F'</span>,<br>        &#125;,<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'G'</span>,<br>        &#125;<br>      ]<br>    &#125;,<br>    &#123;<br><span class="hljs-symbol">      name:</span> <span class="hljs-string">'C'</span>,<br><span class="hljs-symbol">      children:</span> [<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'H'</span><br>        &#125;<br>      ]<br>    &#125;,<br>    &#123;<br><span class="hljs-symbol">      name:</span> <span class="hljs-string">'D'</span>,<br><span class="hljs-symbol">      children:</span> [<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'I'</span>,<br>        &#125;,<br>        &#123;<br><span class="hljs-symbol">          name:</span> <span class="hljs-string">'J'</span>,<br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>我们如何获取根节点的所有叶子节点个数呢 ？</strong></p><p>递归代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取根节点的所有 叶子节点 个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>json Object 对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLeafCountTree</span>(<span class="hljs-params">json</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!json.children)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">let</span> leafCount = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; json.children.length ; i++)&#123;<br>          <span class="hljs-comment">// leafCount = leafCount + getLeafCountTree(json.children[i]);</span><br>          leafCount = leafCount + <span class="hljs-built_in">arguments</span>.callee(json.children[i]);<br>      &#125;<br>      <span class="hljs-keyword">return</span> leafCount;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>递归遍历是比较常用的方法，比如：省市区遍历成树、多叉树、阶乘等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>算法</tag>
      
      <tag>递归</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js拷贝</title>
    <link href="/2018/10/01/js%E6%8B%B7%E8%B4%9D/"/>
    <url>/2018/10/01/js%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h1><h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><p>数据分为基本数据类型(String, Number, Boolean, Null, Undefined，Symbol)和对象数据类型。</p><ul><li>基本数据类型的特点：直接存储在栈(stack)中的数据</li><li>引用数据类型的特点：<strong>存储的是该对象在栈中引用，真实的数据存放在堆内存里</strong></li></ul><p>引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。<br><a href="https://camo.githubusercontent.com/81f67daac67561a6d6cc48d768fc97a34bde6493/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646131373166333062363263653f773d34353926683d33343726663d706e6726733d3131363530" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/81f67daac67561a6d6cc48d768fc97a34bde6493/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646131373166333062363263653f773d34353926683d33343726663d706e6726733d3131363530" srcset="/img/loading.gif" alt="img"></a></p><h2 id="二、浅拷贝与深拷贝"><a href="#二、浅拷贝与深拷贝" class="headerlink" title="二、浅拷贝与深拷贝"></a>二、浅拷贝与深拷贝</h2><p><strong>深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的</strong>。</p><p>深拷贝和浅拷贝的示意图大致如下：<br><a href="https://camo.githubusercontent.com/eea7ec15db8533c906fb29332a630b15e6493b98/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f32392f313634653638353664373666663136313f773d33313026683d32323726663d706e6726733d3439393539" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/eea7ec15db8533c906fb29332a630b15e6493b98/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f32392f313634653638353664373666663136313f773d33313026683d32323726663d706e6726733d3439393539" srcset="/img/loading.gif" alt="img"></a><br><strong>浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。</strong></p><h2 id="三、赋值和浅拷贝的区别"><a href="#三、赋值和浅拷贝的区别" class="headerlink" title="三、赋值和浅拷贝的区别"></a>三、赋值和浅拷贝的区别</h2><ul><li>当我们把一个对象赋值给一个新的变量时，<strong>赋的其实是该对象的在栈中的地址，而不是堆中的数据</strong>。也就是两个对象指向的是同一个存储空间，无论哪个对象发生改变，其实都是改变的存储空间的内容，因此，两个对象是联动的。</li><li>浅拷贝是按位拷贝对象，<strong>它会创建一个新对象</strong>，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址 ，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源。</li></ul><p>我们先来看两个例子，对比赋值与浅拷贝会对原对象带来哪些改变？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 对象赋值</span><br> <span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-string">'name'</span> : <span class="hljs-string">'zhangsan'</span>,<br>    <span class="hljs-string">'age'</span> :  <span class="hljs-string">'18'</span>,<br>    <span class="hljs-string">'language'</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]],<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = obj1;<br>obj2.name = <span class="hljs-string">"lisi"</span>;<br>obj2.language[<span class="hljs-number">1</span>] = [<span class="hljs-string">"二"</span>,<span class="hljs-string">"三"</span>];<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj1'</span>,obj1)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj2'</span>,obj2)<br></code></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/52674bedb7c85a70cdc3575190a71b1e58dbea49/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646136333835373139373833663f773d34313426683d33363126663d706e6726733d3330303337" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/52674bedb7c85a70cdc3575190a71b1e58dbea49/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646136333835373139373833663f773d34313426683d33363126663d706e6726733d3330303337" srcset="/img/loading.gif" alt="img"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 浅拷贝</span><br> <span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-string">'name'</span> : <span class="hljs-string">'zhangsan'</span>,<br>    <span class="hljs-string">'age'</span> :  <span class="hljs-string">'18'</span>,<br>    <span class="hljs-string">'language'</span> : [<span class="hljs-number">1</span>,[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]],<br>&#125;;<br> <span class="hljs-keyword">var</span> obj3 = shallowCopy(obj1);<br> obj3.name = <span class="hljs-string">"lisi"</span>;<br> obj3.language[<span class="hljs-number">1</span>] = [<span class="hljs-string">"二"</span>,<span class="hljs-string">"三"</span>];<br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">shallowCopy</span>(<span class="hljs-params">src</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> dst = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> prop <span class="hljs-keyword">in</span> src) &#123;<br>        <span class="hljs-keyword">if</span> (src.hasOwnProperty(prop)) &#123;<br>            dst[prop] = src[prop];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dst;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj1'</span>,obj1)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'obj3'</span>,obj3)<br></code></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/85ea6835071bf48d8aa68dafc129772bf6342f1b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646136623034396331363136613f773d34313526683d33363226663d706e6726733d3331323930" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/85ea6835071bf48d8aa68dafc129772bf6342f1b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646136623034396331363136613f773d34313526683d33363226663d706e6726733d3331323930" srcset="/img/loading.gif" alt="img"></a><br>上面例子中，obj1是原始数据，obj2是赋值操作得到，而obj3浅拷贝得到。我们可以很清晰看到对原始数据的影响，具体请看下表：</p><p><a href="https://camo.githubusercontent.com/20a8e54f1a5824e705d987ef4d55d647c7527bac/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646137346434356433313033623f773d36323026683d31383926663d706e6726733d3134393030" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/20a8e54f1a5824e705d987ef4d55d647c7527bac/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f31322f32332f313637646137346434356433313033623f773d36323026683d31383926663d706e6726733d3134393030" srcset="/img/loading.gif" alt="img"></a></p><h2 id="四、浅拷贝的实现方式"><a href="#四、浅拷贝的实现方式" class="headerlink" title="四、浅拷贝的实现方式"></a>四、浅拷贝的实现方式</h2><h4 id="1-Object-assign"><a href="#1-Object-assign" class="headerlink" title="1.Object.assign()"></a>1.Object.assign()</h4><p>Object.assign() 方法可以把任意多个的源对象自身的可枚举属性拷贝给目标对象，然后返回目标对象。但是 Object.assign()进行的是浅拷贝，拷贝的是对象的属性的引用，而不是对象本身。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = &#123; <span class="hljs-attr">a</span>: &#123;<span class="hljs-attr">a</span>: <span class="hljs-string">"kobe"</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">39</span>&#125; &#125;;<br><span class="hljs-keyword">var</span> initalObj = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;, obj);<br>initalObj.a.a = <span class="hljs-string">"wade"</span>;<br><span class="hljs-built_in">console</span>.log(obj.a.a); <span class="hljs-comment">//wade</span><br></code></pre></td></tr></table></figure><p>注意：<strong>当object只有一层的时候，是深拷贝</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> obj = &#123;<br>    username: <span class="hljs-string">'kobe'</span><br>    &#125;;<br><span class="hljs-keyword">let</span> obj2 = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,obj);<br>obj2.username = <span class="hljs-string">'wade'</span>;<br><span class="hljs-built_in">console</span>.log(obj);<span class="hljs-comment">//&#123;username: "kobe"&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-Array-prototype-concat"><a href="#2-Array-prototype-concat" class="headerlink" title="2.Array.prototype.concat()"></a>2.Array.prototype.concat()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    username: <span class="hljs-string">'kobe'</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr2=arr.concat();    <br>arr2[<span class="hljs-number">2</span>].username = <span class="hljs-string">'wade'</span>;<br><span class="hljs-built_in">console</span>.log(arr);<br></code></pre></td></tr></table></figure><p>修改新对象会改到原对象:<br><a href="https://camo.githubusercontent.com/448b39655dbe148ced2d1732f47a746f77160191/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653663353538363838656238353f773d33303426683d31303426663d706e6726733d36313433" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/448b39655dbe148ced2d1732f47a746f77160191/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653663353538363838656238353f773d33303426683d31303426663d706e6726733d36313433" srcset="/img/loading.gif" alt="img"></a></p><h4 id="3-Array-prototype-slice"><a href="#3-Array-prototype-slice" class="headerlink" title="3.Array.prototype.slice()"></a>3.Array.prototype.slice()</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    username: <span class="hljs-string">' kobe'</span><br>    &#125;];<br><span class="hljs-keyword">let</span> arr3 = arr.slice();<br>arr3[<span class="hljs-number">2</span>].username = <span class="hljs-string">'wade'</span><br><span class="hljs-built_in">console</span>.log(arr);<br></code></pre></td></tr></table></figure><p>同样修改新对象会改到原对象:</p><p><a href="https://camo.githubusercontent.com/086592407703335fa9f3019e0670bdef94cca880/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653663633832303232626130323f773d32393126683d31303326663d706e6726733d36303637" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/086592407703335fa9f3019e0670bdef94cca880/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653663633832303232626130323f773d32393126683d31303326663d706e6726733d36303637" srcset="/img/loading.gif" alt="img"></a><br><strong>关于Array的slice和concat方法的补充说明</strong>：Array的slice和concat方法不修改原数组，只会返回一个浅复制了原数组中的元素的一个新数组。</p><p>原数组的元素会按照下述规则拷贝：</p><ul><li>如果该元素是个对象引用(不是实际的对象)，slice 会拷贝这个对象引用到新的数组里。两个对象引用都引用了同一个对象。如果被引用的对象发生改变，则新的和原来的数组中的这个元素也会发生改变。</li><li>对于字符串、数字及布尔值来说（不是 String、Number 或者 Boolean 对象），slice 会拷贝这些值到新的数组里。在别的数组里修改这些字符串或数字或是布尔值，将不会影响另一个数组。</li></ul><p>可能这段话晦涩难懂，我们举个例子，将上面的例子小作修改：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">let arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    username: <span class="hljs-string">' kobe'</span><br>    &#125;];<br>let arr3 = arr.slice();<br>arr3[<span class="hljs-number">1</span>] = <span class="hljs-number">2</span><br>console.log(arr,arr3);<br></code></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/397066da05d3f33d75687788814fba73740ea6ef/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33312f313634656266393339393961383634383f773d34303526683d31303926663d706e6726733d3131313634" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/397066da05d3f33d75687788814fba73740ea6ef/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33312f313634656266393339393961383634383f773d34303526683d31303926663d706e6726733d3131313634" srcset="/img/loading.gif" alt="img"></a></p><h2 id="五、深拷贝的实现方式"><a href="#五、深拷贝的实现方式" class="headerlink" title="五、深拷贝的实现方式"></a>五、深拷贝的实现方式</h2><h4 id="1-JSON-parse-JSON-stringify"><a href="#1-JSON-parse-JSON-stringify" class="headerlink" title="1.JSON.parse(JSON.stringify())"></a>1.JSON.parse(JSON.stringify())</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    username: <span class="hljs-string">' kobe'</span><br>&#125;];<br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(arr));<br>arr4[<span class="hljs-number">2</span>].username = <span class="hljs-string">'duncan'</span>; <br><span class="hljs-built_in">console</span>.log(arr, arr4)<br></code></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/446a8ad21ab859e4568c0b5e9ceb8020ebf17395/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653664356636343264343430613f773d34313826683d31303426663d706e6726733d3130343932" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/446a8ad21ab859e4568c0b5e9ceb8020ebf17395/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653664356636343264343430613f773d34313826683d31303426663d706e6726733d3130343932" srcset="/img/loading.gif" alt="img"></a><br>原理： 用JSON.stringify将对象转成JSON字符串，再用JSON.parse()把字符串解析成对象，一去一来，新的对象产生了，而且对象会开辟新的栈，实现深拷贝。</p><p><strong>这种方法虽然可以实现数组或对象深拷贝,但不能处理函数</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, &#123;<br>    username: <span class="hljs-string">' kobe'</span><br>&#125;,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;];<br><span class="hljs-keyword">let</span> arr4 = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(arr));<br>arr4[<span class="hljs-number">2</span>].username = <span class="hljs-string">'duncan'</span>; <br><span class="hljs-built_in">console</span>.log(arr, arr4)<br></code></pre></td></tr></table></figure><p><a href="https://camo.githubusercontent.com/cd2a62ed3493b2a43f1524ae8dc14a6c4ef18360/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653664616131346131663862653f773d34333826683d31313826663d706e6726733d3132313535" target="_blank" rel="noopener"><img src="https://camo.githubusercontent.com/cd2a62ed3493b2a43f1524ae8dc14a6c4ef18360/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031382f372f33302f313634653664616131346131663862653f773d34333826683d31313826663d706e6726733d3132313535" srcset="/img/loading.gif" alt="img"></a><br>这是因为JSON.stringify() 方法是将一个JavaScript值(对象或者数组)转换为一个 JSON字符串，不能接受函数</p><h4 id="2-手写递归方法"><a href="#2-手写递归方法" class="headerlink" title="2.手写递归方法"></a>2.手写递归方法</h4><p>递归方法实现深度克隆原理：<strong>遍历对象、数组直到里边都是基本数据类型，然后再去复制，就是深度拷贝</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">//定义检测数据类型的功能函数</span><br><span class="hljs-function">function <span class="hljs-title">checkedType</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> Object.prototype.toString.call(<span class="hljs-keyword">target</span>).slice(<span class="hljs-number">8</span>, <span class="hljs-number">-1</span>)<br>&#125;<br><span class="hljs-comment">//实现深度克隆---对象/数组</span><br><span class="hljs-function">function <span class="hljs-title">clone</span><span class="hljs-params">(<span class="hljs-keyword">target</span>)</span> </span>&#123;<br>  <span class="hljs-comment">//判断拷贝的数据类型</span><br>  <span class="hljs-comment">//初始化变量result 成为最终克隆的数据</span><br>  let result,<br>    targetType = checkedType(<span class="hljs-keyword">target</span>)<br>  <span class="hljs-keyword">if</span> (targetType === <span class="hljs-string">'Object'</span>) &#123;<br>    result = &#123;&#125;<br>  &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(targetType === <span class="hljs-string">'Array'</span>)</span> </span>&#123;<br>    result = []<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">target</span><br>  &#125;<br>  <span class="hljs-comment">//遍历目标数据</span><br>  <span class="hljs-keyword">for</span> (let i in <span class="hljs-keyword">target</span>) &#123;<br>    <span class="hljs-comment">//获取遍历数据结构的每一项值。</span><br>    let value = <span class="hljs-keyword">target</span>[i]<br>    <span class="hljs-comment">//判断目标结构里的每一值是否存在对象/数组</span><br>    <span class="hljs-keyword">if</span> (checkedType(value) === <span class="hljs-string">'Object'</span> || checkedType(value) === <span class="hljs-string">'Array'</span>) &#123;<br>      <span class="hljs-comment">//对象/数组里嵌套了对象/数组</span><br>      <span class="hljs-comment">//继续遍历获取到value值</span><br>      result[i] = clone(value)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">//获取到value值是基本的数据类型或者是函数。</span><br>      result[i] = value<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-函数库lodash"><a href="#3-函数库lodash" class="headerlink" title="3.函数库lodash"></a>3.函数库lodash</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">var</span> <span class="hljs-string">_</span> <span class="hljs-string">=</span> <span class="hljs-string">require('lodash');</span><br><span class="hljs-string">var</span> <span class="hljs-string">obj1</span> <span class="hljs-string">=</span> <span class="hljs-string">&#123;</span><br>    <span class="hljs-attr">a:</span> <span class="hljs-number">1</span><span class="hljs-string">,</span><br>    <span class="hljs-attr">b:</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">f:</span> <span class="hljs-string">&#123;</span> <span class="hljs-attr">g:</span> <span class="hljs-number">1</span> <span class="hljs-string">&#125;</span> <span class="hljs-string">&#125;,</span><br>    <span class="hljs-attr">c:</span> <span class="hljs-string">[1,</span> <span class="hljs-number">2</span><span class="hljs-string">,</span> <span class="hljs-number">3</span><span class="hljs-string">]</span><br><span class="hljs-string">&#125;;</span><br><span class="hljs-string">var</span> <span class="hljs-string">obj2</span> <span class="hljs-string">=</span> <span class="hljs-string">_.cloneDeep(obj1);</span><br><span class="hljs-string">console.log(obj1.b.f</span> <span class="hljs-string">===</span> <span class="hljs-string">obj2.b.f);</span><br><span class="hljs-string">//</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>数据结构</tag>
      
      <tag>copy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>js数据结构-线性表</title>
    <link href="/2018/10/01/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    <url>/2018/10/01/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E7%BA%BF%E6%80%A7%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript数据结构-线性表"><a href="#JavaScript数据结构-线性表" class="headerlink" title="JavaScript数据结构-线性表"></a>JavaScript数据结构-线性表</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><ol><li>基础知识就像是一座大楼的地基，它决定了我们的技术高度。</li><li>我们应该多掌握一些可移值的技术或者再过十几年应该都不会过时的技术，数据结构与算法就是其中之一。</li></ol></blockquote><p>栈、队列、链表、堆 是数据结构与算法中的基础知识，是程序员的地基。</p><p>笔者写的 <strong>JavaScript 数据结构与算法之美</strong> 系列用的语言是 <strong>JavaScript</strong> ，旨在入门数据结构与算法和方便以后复习。</p><h2 id="1-线性表与非线性表"><a href="#1-线性表与非线性表" class="headerlink" title="1. 线性表与非线性表"></a>1. 线性表与非线性表</h2><p><strong>线性表</strong>（Linear List）：就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。数组、链表、队列、栈 等就是线性表结构。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-cfe998bce08fae43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="线性表"></p><p><strong>非线性表</strong>：数据之间并不是简单的前后关系。二叉树、堆、图 就是非线性表。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-9ad7a8944240106b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="非线性表"></p><p>本文主要讲线性表，非线性表会在后面章节讲。</p><h2 id="2-数组"><a href="#2-数组" class="headerlink" title="2. 数组"></a>2. 数组</h2><p><img src="https://upload-images.jianshu.io/upload_images/12890819-3332820f2b3e4df2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="数组"></p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul><li>数组 (Array) 是一个有序的数据集合，我们可以通过数组名称 (name) 和索引 (index) 进行访问。</li><li>数组的索引是从 0 开始的。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>数组是用一组连续的内存空间来存储的</strong>。 所以数组支持 <strong>随机访问</strong>，根据下标随机访问的时间复杂度为 O(1)。</li><li><strong>低效的插入和删除</strong>。 数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效，因为底层通常是要进行大量的数据搬移来保持数据的连续性。 插入与删除的时间复杂度如下： 插入：从最好 O(1) ，最坏 O(n) ，平均 O(n) 删除：从最好 O(1) ，最坏 O(n) ，平均 O(n)</li></ul><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>但是因为 JavaScript 是<strong>弱类型</strong>的语言，弱类型则允许隐式类型转换。</p><p><strong>隐式</strong>：是指源码中没有明显的类型转换代码。也就是说，一个变量，可以赋值字符串，也可以赋值数值。</p><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> <span class="hljs-built_in">str</span> = <span class="hljs-string">"string"</span><br><span class="hljs-built_in">str</span> = <span class="hljs-number">123</span> <br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">str</span>)  <span class="hljs-comment">//   123</span><br></code></pre></td></tr></table></figure><p>你还可以直接让字符串类型的变量和数值类型的变量相加，虽然得出的最终结果未必是你想象的那样，但一定不会报错。</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span> = <span class="hljs-number">123</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span> = <span class="hljs-string">"456"</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">c</span> = a + b<br>// 数值加字符串，结果是字符串<br>console.log(c)  //   <span class="hljs-string">"123456"</span><br></code></pre></td></tr></table></figure><p>数组的每一项可以是不同的类型，比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 数组的类型有 数值、字符串，还可以随意变更类型</span><br><span class="hljs-keyword">const</span> arr = [ <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-string">"abc"</span> ]<br>arr[<span class="hljs-number">2</span>] = &#123; <span class="hljs-string">"key"</span>: <span class="hljs-string">"value"</span> &#125;  <span class="hljs-comment">// 把数组的第二项变成对象</span><br>console.<span class="hljs-built_in">log</span>(arr) <span class="hljs-comment">//  [ 12, 34,  &#123; "key": "value"&#125; ]</span><br></code></pre></td></tr></table></figure><p>定义的数组的大小是可变的，不像强类型语言，定义某个数组变量的时候就要定义该变量的大小。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">const arr = [ <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-string">"abc"</span>] <br>arr.push(&#123; <span class="hljs-string">"key"</span>: <span class="hljs-string">"value"</span> &#125;) <span class="hljs-regexp">//</span> 添加一项 对象<br>consolelog(arr) <span class="hljs-regexp">//</span>  [ <span class="hljs-number">12</span>, <span class="hljs-number">34</span>, <span class="hljs-string">"abc"</span>, &#123; <span class="hljs-string">"key"</span>: <span class="hljs-string">"value"</span> &#125; ]<br></code></pre></td></tr></table></figure><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>JavaScript 原生支持数组，而且提供了很多操作方法，这里不展开讲。</p><h2 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h2><p><img src="https://upload-images.jianshu.io/upload_images/12890819-6110623f40c1ad86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="栈"></p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><ol><li>后进者先出，先进者后出，简称 <strong>后进先出</strong>（LIFO），这就是典型的<code>栈</code>结构。</li><li>新添加的或待删除的元素都保存在栈的末尾，称作<code>栈顶</code>，另一端就叫<code>栈底</code>。</li><li>在栈里，新元素都靠近栈顶，旧元素都接近栈底。</li><li>从栈的操作特性来看，是一种 <code>操作受限</code>的线性表，只允许在一端插入和删除数据。</li><li>不包含任何元素的栈称为<code>空栈</code>。</li></ol><p>栈也被用在编程语言的编译器和内存中保存变量、方法调用等，比如函数的调用栈。</p><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><p>栈的方法：</p><ul><li>push(element)：添加一个（或几个）新元素到栈顶。</li><li>pop()：移除栈顶的元素，同时返回被移除的元素。</li><li>peek()：返回栈顶的元素，不对栈做任何修改。</li><li>isEmpty()：如果栈里没有任何元素就返回 true，否则返回 false。</li><li>clear()：移除栈里的所有元素。</li><li>size()：返回栈里的元素个数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Stack类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Stack</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">this</span>.items = [];<br><br>  <span class="hljs-comment">// 添加新元素到栈顶</span><br>  <span class="hljs-keyword">this</span>.push = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.items.push(element);<br>  &#125;;<br>  <span class="hljs-comment">// 移除栈顶元素，同时返回被移除的元素</span><br>  <span class="hljs-keyword">this</span>.pop = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.pop();<br>  &#125;;<br>  <span class="hljs-comment">// 查看栈顶元素</span><br>  <span class="hljs-keyword">this</span>.peek = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-keyword">this</span>.items.length - <span class="hljs-number">1</span>];<br>  &#125;;<br>  <span class="hljs-comment">// 判断是否为空栈</span><br>  <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length === <span class="hljs-number">0</span>;<br>  &#125;;<br>  <span class="hljs-comment">// 清空栈</span><br>  <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.items = [];<br>  &#125;;<br>  <span class="hljs-comment">// 查询栈的长度</span><br>  <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length;<br>  &#125;;<br>  <span class="hljs-comment">// 打印栈里的元素</span><br>  <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.items.toString());<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建Stack实例</span><br>var <span class="hljs-built_in">stack</span> = <span class="hljs-keyword">new</span> Stack();<br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.isEmpty()); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">stack</span>.push(<span class="hljs-number">5</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">stack</span>.push(<span class="hljs-number">8</span>); <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">peek</span>()); <span class="hljs-comment">// 8</span><br><span class="hljs-built_in">stack</span>.push(<span class="hljs-number">11</span>); <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 3</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.isEmpty()); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">stack</span>.push(<span class="hljs-number">15</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">stack</span>.pop(); <span class="hljs-comment">// 15</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">stack</span>.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 5,8,11</span><br><span class="hljs-built_in">stack</span>.<span class="hljs-built_in">clear</span>(); <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">stack</span>.<span class="hljs-built_in">size</span>()); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p>栈的应用实例：<a href="https://github.com/biaochenxuying/blog/issues/30" target="_blank" rel="noopener">JavaScript 数据结构与算法之美 - 实现一个前端路由，如何实现浏览器的前进与后退 ？</a></p><h2 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h2><p><img src="https://upload-images.jianshu.io/upload_images/12890819-e16bb0e8305caa6b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="队列"></p><h3 id="普通队列"><a href="#普通队列" class="headerlink" title="普通队列"></a>普通队列</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li>队列是遵循 FIFO（First In First Out，<strong>先进先出</strong>）原则的一组有序的项。</li><li>队列在尾部添加新元素，并从顶部移除元素。</li><li>最新添加的元素必须排在队列的末尾。</li><li>队列只有 入队 push() 和出队 pop()。</li></ul><h4 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h4><p>队列里面有一些声明的辅助方法：</p><ul><li>enqueue(element)：向队列尾部添加新项。</li><li>dequeue()：移除队列的第一项，并返回被移除的元素。</li><li>front()：返回队列中第一个元素，队列不做任何变动。</li><li>isEmpty()：如果队列中不包含任何元素，返回 true，否则返回 false。</li><li>size()：返回队列包含的元素个数，与数组的 length 属性类似。</li><li>print()：打印队列中的元素。</li><li>clear()：清空整个队列。</li></ul><p>代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// Queue类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Queue</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.items = [];<br><br>    <span class="hljs-comment">// 向队列尾部添加元素</span><br>    <span class="hljs-keyword">this</span>.enqueue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>        <span class="hljs-keyword">this</span>.items.push(element);<br>    &#125;;<br><br>    <span class="hljs-comment">// 移除队列的第一个元素，并返回被移除的元素</span><br>    <span class="hljs-keyword">this</span>.dequeue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.shift();<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回队列的第一个元素</span><br>    <span class="hljs-keyword">this</span>.front = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items[<span class="hljs-number">0</span>];<br>    &#125;;<br><br>    <span class="hljs-comment">// 判断是否为空队列</span><br>    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length === <span class="hljs-number">0</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">// 获取队列的长度</span><br>    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.items.length;<br>    &#125;;<br><br>    <span class="hljs-comment">// 清空队列</span><br>    <span class="hljs-keyword">this</span>.clear = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">this</span>.items = [];<br>    &#125;;<br><br>    <span class="hljs-comment">// 打印队列里的元素</span><br>    <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.items.toString());<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// 创建Queue实例</span><br><span class="hljs-built_in">var</span> <span class="hljs-built_in">queue</span> = <span class="hljs-literal">new</span> <span class="hljs-built_in">Queue</span>();<br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.isEmpty()); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">'John'</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">'Jack'</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">queue</span>.enqueue(<span class="hljs-string">'Camila'</span>); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">queue</span>.print(); <span class="hljs-comment">// "John,Jack,Camila"</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.size()); <span class="hljs-comment">// 3</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.isEmpty()); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">queue</span>.dequeue(); <span class="hljs-comment">// "John"</span><br><span class="hljs-built_in">queue</span>.dequeue(); <span class="hljs-comment">// "Jack"</span><br><span class="hljs-built_in">queue</span>.print(); <span class="hljs-comment">// "Camila"</span><br><span class="hljs-built_in">queue</span>.clear(); <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-keyword">log</span>(<span class="hljs-built_in">queue</span>.size()); <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h3 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p>优先队列中元素的添加和移除是依赖<code>优先级</code>的。</p><p><strong>应用</strong></p><ul><li>一个现实的例子就是机场登机的顺序。头等舱和商务舱乘客的优先级要高于经济舱乘客。</li><li>再比如：火车，老年人、孕妇和带小孩的乘客是享有优先检票权的。</li></ul><p><strong>优先队列分为两类</strong></p><ul><li>最小优先队列</li><li>最大优先队列</li></ul><p>最小优先队列是把优先级的值最小的元素被放置到队列的最前面（代表最高的优先级）。 比如：有四个元素：”John”, “Jack”, “Camila”, “Tom”，他们的优先级值分别为 4，3，2，1。 那么最小优先队列排序应该为：”Tom”，”Camila”，”Jack”，”John”。</p><p>最大优先队列正好相反，把优先级值最大的元素放置在队列的最前面。 以上面的为例，最大优先队列排序应该为：”John”, “Jack”, “Camila”, “Tom”。</p><p><strong>实现</strong></p><p>实现一个优先队列，有两种选项：</p><ul><li><ol><li>设置优先级，根据优先级正确添加元素，然后和普通队列一样正常移除</li></ol></li><li><ol><li>设置优先级，和普通队列一样正常按顺序添加，然后根据优先级移除</li></ol></li></ul><p>这里最小优先队列和最大优先队列我都采用第一种方式实现，大家可以尝试一下第二种。</p><p>下面只重写 enqueue() 方法和 print() 方法，其他方法和上面的普通队列完全相同。</p><p><strong>实现最小优先队列</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 定义最小优先队列</span><br>function MinPriorityQueue () &#123;<br>  <span class="hljs-keyword">this</span>.items = [];<br><br>  <span class="hljs-keyword">this</span>.enqueue = enqueue;<br>  <span class="hljs-keyword">this</span>.dequeue = dequeue;<br>  <span class="hljs-keyword">this</span>.front = front;<br>  <span class="hljs-keyword">this</span>.isEmpty = isEmpty;<br>  <span class="hljs-keyword">this</span>.size = size;<br>  <span class="hljs-keyword">this</span>.clear = clear;<br>  <span class="hljs-keyword">this</span>.print = print;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现最小优先队列 enqueue() 方法和 print() 方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 优先队列添加元素，要根据优先级判断在队列中的插入顺序</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">enqueue</span> (<span class="hljs-params">element, priority</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> queueElement = &#123;<br>    element: element,<br>    priority: priority<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) &#123;<br>    <span class="hljs-keyword">this</span>.items.push(queueElement);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> added = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.size(); i++) &#123;<br>      <span class="hljs-keyword">if</span> (queueElement.priority &lt; <span class="hljs-keyword">this</span>.items[i].priority) &#123;<br>        <span class="hljs-keyword">this</span>.items.splice(i, <span class="hljs-number">0</span>, queueElement);<br>        added = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span> ;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!added) &#123;<br>      <span class="hljs-keyword">this</span>.items.push(queueElement);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 打印队列里的元素</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> strArr = [];<br><br>  strArr = <span class="hljs-keyword">this</span>.items.map(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">item</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;item.element&#125;</span>-&gt;<span class="hljs-subst">$&#123;item.priority&#125;</span>`</span>;<br>  &#125;);<br><br>  <span class="hljs-built_in">console</span>.log(strArr.toString());<br>&#125;<br></code></pre></td></tr></table></figure><p>最小优先队列测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建最小优先队列minPriorityQueue实例</span><br>var minPriorityQueue = <span class="hljs-keyword">new</span> MinPriorityQueue();<br><br>console.<span class="hljs-built_in">log</span>(minPriorityQueue.isEmpty());     <span class="hljs-comment">// true</span><br>minPriorityQueue.enqueue(<span class="hljs-string">"John"</span>, <span class="hljs-number">1</span>);         <span class="hljs-comment">// undefined</span><br>minPriorityQueue.enqueue(<span class="hljs-string">"Jack"</span>, <span class="hljs-number">3</span>);         <span class="hljs-comment">// undefined</span><br>minPriorityQueue.enqueue(<span class="hljs-string">"Camila"</span>, <span class="hljs-number">2</span>);       <span class="hljs-comment">// undefined</span><br>minPriorityQueue.enqueue(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">3</span>);          <span class="hljs-comment">// undefined</span><br>minPriorityQueue.<span class="hljs-built_in">print</span>();                    <span class="hljs-comment">// "John-&gt;1,Camila-&gt;2,Jack-&gt;3,Tom-&gt;3"</span><br>console.<span class="hljs-built_in">log</span>(minPriorityQueue.<span class="hljs-built_in">size</span>());        <span class="hljs-comment">// 4</span><br>console.<span class="hljs-built_in">log</span>(minPriorityQueue.isEmpty());     <span class="hljs-comment">// false</span><br>minPriorityQueue.dequeue();                  <span class="hljs-comment">// &#123;element: "John", priority: 1&#125;</span><br>minPriorityQueue.dequeue();                  <span class="hljs-comment">// &#123;element: "Camila", priority: 2&#125;</span><br>minPriorityQueue.<span class="hljs-built_in">print</span>();                    <span class="hljs-comment">// "Jack-&gt;3,Tom-&gt;3"</span><br>minPriorityQueue.<span class="hljs-built_in">clear</span>();                    <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(minPriorityQueue.<span class="hljs-built_in">size</span>());        <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><p><strong>实现最大优先队列</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 最大优先队列 MaxPriorityQueue 类</span><br>function MaxPriorityQueue () &#123;<br>  <span class="hljs-keyword">this</span>.items = [];<br><br>  <span class="hljs-keyword">this</span>.enqueue = enqueue;<br>  <span class="hljs-keyword">this</span>.dequeue = dequeue;<br>  <span class="hljs-keyword">this</span>.front = front;<br>  <span class="hljs-keyword">this</span>.isEmpty = isEmpty;<br>  <span class="hljs-keyword">this</span>.size = size;<br>  <span class="hljs-keyword">this</span>.clear = clear;<br>  <span class="hljs-keyword">this</span>.print = print;<br>&#125;<br><br><span class="hljs-comment">// 优先队列添加元素，要根据优先级判断在队列中的插入顺序</span><br>function enqueue (element, priority) &#123;<br>  <span class="hljs-keyword">var</span> queueElement = &#123;<br>    element: element,<br>    priority: priority<br>  &#125;;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isEmpty()) &#123;<br>    <span class="hljs-keyword">this</span>.items.push(queueElement);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> added = <span class="hljs-literal">false</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.items.length; i++) &#123;<br>      <span class="hljs-comment">// 注意，只需要将这里改为大于号就可以了</span><br>      <span class="hljs-keyword">if</span> (queueElement.priority &gt; <span class="hljs-keyword">this</span>.items[i].priority) &#123;<br>        <span class="hljs-keyword">this</span>.items.splice(i, <span class="hljs-number">0</span>, queueElement);<br>        added = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">break</span> ;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (!added) &#123;<br>      <span class="hljs-keyword">this</span>.items.push(queueElement);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>最大优先队列测试：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 创建最大优先队列maxPriorityQueue实例</span><br>var maxPriorityQueue = <span class="hljs-keyword">new</span> MaxPriorityQueue();<br><br>console.<span class="hljs-built_in">log</span>(maxPriorityQueue.isEmpty());     <span class="hljs-comment">// true</span><br>maxPriorityQueue.enqueue(<span class="hljs-string">"John"</span>, <span class="hljs-number">1</span>);         <span class="hljs-comment">// undefined</span><br>maxPriorityQueue.enqueue(<span class="hljs-string">"Jack"</span>, <span class="hljs-number">3</span>);         <span class="hljs-comment">// undefined</span><br>maxPriorityQueue.enqueue(<span class="hljs-string">"Camila"</span>, <span class="hljs-number">2</span>);       <span class="hljs-comment">// undefined</span><br>maxPriorityQueue.enqueue(<span class="hljs-string">"Tom"</span>, <span class="hljs-number">3</span>);          <span class="hljs-comment">// undefined</span><br>maxPriorityQueue.<span class="hljs-built_in">print</span>();                    <span class="hljs-comment">// "Jack-&gt;3,Tom-&gt;3,Camila-&gt;2,John-&gt;1"</span><br>console.<span class="hljs-built_in">log</span>(maxPriorityQueue.<span class="hljs-built_in">size</span>());        <span class="hljs-comment">// 4</span><br>console.<span class="hljs-built_in">log</span>(maxPriorityQueue.isEmpty());     <span class="hljs-comment">// false</span><br>maxPriorityQueue.dequeue();                  <span class="hljs-comment">// &#123;element: "Jack", priority: 3&#125;</span><br>maxPriorityQueue.dequeue();                  <span class="hljs-comment">// &#123;element: "Tom", priority: 3&#125;</span><br>maxPriorityQueue.<span class="hljs-built_in">print</span>();                    <span class="hljs-comment">// "Camila-&gt;2,John-&gt;1"</span><br>maxPriorityQueue.<span class="hljs-built_in">clear</span>();                    <span class="hljs-comment">// undefined</span><br>console.<span class="hljs-built_in">log</span>(maxPriorityQueue.<span class="hljs-built_in">size</span>());        <span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure><h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p>循环队列，顾名思义，它长得像一个环。把它想像成一个圆的钟就对了。</p><p>关键是：确定好队空和队满的判定条件。</p><p>循环队列的一个例子就是击鼓传花游戏（Hot Potato）。在这个游戏中，孩子们围城一个圆圈，击鼓的时候把花尽快的传递给旁边的人。某一时刻击鼓停止，这时花在谁的手里，谁就退出圆圈直到游戏结束。重复这个过程，直到只剩一个孩子（胜者）。</p><p>下面我们在普通队列的基础上，实现一个模拟的击鼓传花游戏，下面只写击鼓传花的代码片段：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 实现击鼓传花</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">hotPotato</span> (<span class="hljs-params">nameList, num</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> queue = <span class="hljs-keyword">new</span> Queue();<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; nameList.length; i++) &#123;<br>    queue.enqueue(nameList[i]);<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> eliminated = <span class="hljs-string">''</span>;<br><br>  <span class="hljs-keyword">while</span> (queue.size() &gt; <span class="hljs-number">1</span>) &#123;<br>    <span class="hljs-comment">// 循环 num 次，队首出来去到队尾</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>      queue.enqueue(queue.dequeue());<br>    &#125;<br>    <span class="hljs-comment">// 循环 num 次过后，移除当前队首的元素</span><br>    eliminated = queue.dequeue();<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;eliminated&#125;</span> 在击鼓传花中被淘汰！`</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 最后只剩一个元素</span><br>  <span class="hljs-keyword">return</span> queue.dequeue();<br>&#125;<br><br><span class="hljs-comment">// 测试</span><br><span class="hljs-keyword">var</span> nameList = [<span class="hljs-string">"John"</span>, <span class="hljs-string">"Jack"</span>, <span class="hljs-string">"Camila"</span>, <span class="hljs-string">"Ingrid"</span>, <span class="hljs-string">"Carl"</span>];<br><span class="hljs-keyword">var</span> winner = hotPotato(nameList, <span class="hljs-number">10</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`最后的胜利者是：<span class="hljs-subst">$&#123;winner&#125;</span>`</span>);<br></code></pre></td></tr></table></figure><p>执行结果为：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-comment">// John 在击鼓传花中被淘汰！</span><br><span class="hljs-comment">// Ingrid 在击鼓传花中被淘汰！ </span><br><span class="hljs-comment">// Jack 在击鼓传花中被淘汰！</span><br><span class="hljs-comment">// Camila 在击鼓传花中被淘汰！</span><br><span class="hljs-comment">// 最后的胜利者是：Carl</span><br></code></pre></td></tr></table></figure><p><strong>队列小结</strong></p><p>一些具有某些额外特性的队列，比如：循环队列、阻塞队列、并发队列。它们在很多偏底层系统、框架、中间件的开发中，起着关键性的作用。</p><p>以上队列的代码要感谢 <a href="https://github.com/leocoder351/data-structure" target="_blank" rel="noopener">leocoder351</a>。</p><h2 id="5-链表"><a href="#5-链表" class="headerlink" title="5. 链表"></a>5. 链表</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><ul><li>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的，它是通过 <strong>指针</strong> 将 <strong>零散的内存块</strong> 串连起来的。</li><li>每个元素由一个存储元素本身的 <strong>节点</strong> 和一个指向下一个元素的 <strong>引用</strong>（也称指针或链接）组成。</li></ul><p>简单的链接结构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-a4cb793a9276d358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="单链表结构图"></p><p>其中，data 中保存着数据，next 保存着下一个链表的引用。 上图中，我们说 data2 跟在 data1 后面，而不是说 data2 是链表中的第二个元素。值得注意的是，我们将链表的尾元素指向了 null 节点，表示链接结束的位置。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li><strong>链表是通过指针将零散的内存块串连起来的</strong>。 所以链表不支持 <strong>随机访问</strong>，如果要找特定的项，只能从头开始遍历，直到找到某个项。 所以访问的时间复杂度为 O(n)。</li><li><strong>高效的插入和删除</strong>。 链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的，只需要考虑相邻结点的指针改变。 所以，在链表中插入和删除一个数据是非常快速的，时间复杂度为 O(1)。</li></ul><p>三种最常见的链表结构，它们分别是：</p><ul><li>单链表</li><li>双向链表</li><li>循环链表</li></ul><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><p><img src="https://upload-images.jianshu.io/upload_images/12890819-a4cb793a9276d358.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="单链表结构图"></p><p>由于链表的起始点的确定比较麻烦，因此很多链表的实现都会在链表的最前面添加一个特殊的节点，称为 <strong>头节点</strong>，表示链表的头部。</p><p>经过改造，链表就成了如下的样子：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-0628fa35ba0f4205.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="有头节点的链表"></p><p>针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以插入与删除的时间复杂度为 O(1)。</p><p>在 d2 节点后面插入 d4 节点：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-06877f74051c3deb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="插入节点"></p><p>删除 d4 节点：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-401fa510e1738758.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="删除节点"></p><h4 id="实现-3"><a href="#实现-3" class="headerlink" title="实现"></a>实现</h4><ul><li>Node 类用来表示节点。</li><li>LinkedList 类提供插入节点、删除节点等一些操作。</li></ul><p>单向链表的八种常用操作：</p><ul><li>append(element)：尾部添加元素。</li><li>insert(position, element)：特定位置插入一个新的项。</li><li>removeAt(position)：特定位置移除一项。</li><li>remove(element)：移除一项。</li><li>indexOf(element)：返回元素在链表中的索引。如果链表中没有该元素则返回 -1。</li><li>isEmpty()：如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false。</li><li>size()：返回链表包含的元素个数，与数组的 length 属性类似。</li><li>getHead()：返回链表的第一个元素。</li><li>toString()：由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值。</li><li>print()：打印链表的所有元素。</li></ul><p>具体代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单链表</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SinglyLinkedList</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>) </span>&#123;<br>        <span class="hljs-keyword">this</span>.element = element; <span class="hljs-comment">// 当前节点的元素</span><br>        <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 下一个节点指针</span><br>    &#125;<br><br>    <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 链表的长度</span><br>    <span class="hljs-keyword">var</span> head = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表的头部节点</span><br><br>    <span class="hljs-comment">// 向链表尾部添加一个新的节点</span><br>    <span class="hljs-keyword">this</span>.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);<br>        <span class="hljs-keyword">var</span> currentNode = head;<br><br>        <span class="hljs-comment">// 判断是否为空链表</span><br>        <span class="hljs-keyword">if</span> (head === <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 是空链表，就把当前节点作为头部节点</span><br>            head = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 从 head 开始一直找到最后一个 node</span><br>            <span class="hljs-keyword">while</span> (currentNode.next) &#123;<br>                <span class="hljs-comment">// 后面还有 node</span><br>                currentNode = currentNode.next;<br>            &#125;<br>            <span class="hljs-comment">// 把当前节点的 next 指针 指向 新的节点</span><br>            currentNode.next = node;<br>        &#125;<br>        <span class="hljs-comment">// 链表的长度加 1</span><br>        length++;<br>    &#125;;<br><br>    <span class="hljs-comment">// 向链表特定位置插入一个新节点</span><br>    <span class="hljs-keyword">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">position, element</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt; length) &#123;<br>            <span class="hljs-comment">// 越界</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);<br>            <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">var</span> currentNode = head;<br>            <span class="hljs-keyword">var</span> previousNode;<br><br>            <span class="hljs-comment">// 在最前插入节点</span><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                node.next = currentNode;<br>                head = node;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 循环找到位置</span><br>                <span class="hljs-keyword">while</span> (index &lt; position) &#123;<br>                    index++;<br>                    previousNode = currentNode;<br>                    currentNode = currentNode.next;<br>                &#125;<br>                <span class="hljs-comment">// 把前一个节点的指针指向新节点，新节点的指针指向当前节点，保持连接性</span><br>                previousNode.next = node;<br>                node.next = currentNode;<br>            &#125;<br><br>            length++;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 从链表的特定位置移除一项</span><br>    <span class="hljs-keyword">this</span>.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">position</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> ((position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt;= length) || length === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 越界</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">var</span> currentNode = head;<br>            <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">var</span> previousNode;<br><br>            <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>                head = currentNode.next;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 循环找到位置</span><br>                <span class="hljs-keyword">while</span> (index &lt; position) &#123;<br>                    index++;<br>                    previousNode = currentNode;<br>                    currentNode = currentNode.next;<br>                &#125;<br>                <span class="hljs-comment">// 把当前节点的 next 指针 指向 当前节点的 next 指针，即是 删除了当前节点</span><br>                previousNode.next = currentNode.next;<br>            &#125;<br><br>            length--;<br><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-comment">// 从链表中移除指定项</span><br>    <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.indexOf(element);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.removeAt(index);<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span><br>    <span class="hljs-keyword">this</span>.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> currentNode = head;<br>        <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">while</span> (currentNode) &#123;<br>            <span class="hljs-keyword">if</span> (currentNode.element === element) &#123;<br>                <span class="hljs-keyword">return</span> index;<br>            &#125;<br><br>            index++;<br>            currentNode = currentNode.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">// 如果链表中不包含任何元素，返回 true，如果链表长度大于 0，返回 false</span><br>    <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> length === <span class="hljs-number">0</span>;<br>    &#125;;<br><br>    <span class="hljs-comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span><br>    <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;;<br><br>    <span class="hljs-comment">// 获取链表头部元素</span><br>    <span class="hljs-keyword">this</span>.getHead = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> head.element;<br>    &#125;;<br><br>    <span class="hljs-comment">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br>    <span class="hljs-keyword">this</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> currentNode = head;<br>        <span class="hljs-keyword">var</span> string = <span class="hljs-string">''</span>;<br><br>        <span class="hljs-keyword">while</span> (currentNode) &#123;<br>            string += <span class="hljs-string">','</span> + currentNode.element;<br>            currentNode = currentNode.next;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> string.slice(<span class="hljs-number">1</span>);<br>    &#125;;<br><br>    <span class="hljs-comment">// 打印链表数据</span><br>    <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.toString());<br>    &#125;;<br><br>    <span class="hljs-comment">// 获取整个链表</span><br>    <span class="hljs-keyword">this</span>.list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'head: '</span>, head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建单向链表实例</span><br>var singlyLinked = <span class="hljs-keyword">new</span> SinglyLinkedList();<br>console.<span class="hljs-built_in">log</span>(singlyLinked.removeAt(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(singlyLinked.isEmpty()); <span class="hljs-comment">// true</span><br>singlyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Tom'</span>);<br>singlyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Peter'</span>);<br>singlyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Paul'</span>);<br>singlyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Tom,Peter,Paul"</span><br>singlyLinked.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'Susan'</span>);<br>singlyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Tom,Peter,Paul"</span><br>singlyLinked.insert(<span class="hljs-number">1</span>, <span class="hljs-string">'Jack'</span>);<br>singlyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Tom,Peter,Paul"</span><br>console.<span class="hljs-built_in">log</span>(singlyLinked.getHead()); <span class="hljs-comment">// "Susan"</span><br>console.<span class="hljs-built_in">log</span>(singlyLinked.isEmpty()); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(singlyLinked.indexOf(<span class="hljs-string">'Peter'</span>)); <span class="hljs-comment">// 3</span><br>console.<span class="hljs-built_in">log</span>(singlyLinked.indexOf(<span class="hljs-string">'Cris'</span>)); <span class="hljs-comment">// -1</span><br>singlyLinked.remove(<span class="hljs-string">'Tom'</span>);<br>singlyLinked.removeAt(<span class="hljs-number">2</span>);<br>singlyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Paul"</span><br>singlyLinked.list(); <span class="hljs-comment">// 具体控制台</span><br></code></pre></td></tr></table></figure><p>整个链表数据在 JavaScript 里是怎样的呢 ？</p><p>为了看这个数据，特意写了个 list 函数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取整个链表</span><br>    <span class="hljs-keyword">this</span>.list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'head: '</span>, head);<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;;<br></code></pre></td></tr></table></figure><p>重点上上面的最后一行代码： singlyLinked.list() ，打印的数据如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-c025219865a1c7de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="img"></p><p>所以，在 JavaScript 中，单链表的真实数据有点类似于对象，实际上是 Node 类生成的实例。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。 而双向链表，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-ba82fe4a414d3372.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="双向链表"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-cebffc624a552030.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="插入"></p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-9d527b59279bbb0c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="删除"></p><p><strong>单向链表与又向链表比较</strong></p><ul><li>双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。 所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。 虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。</li><li>双向链表提供了两种迭代列表的方法：<strong>从头到尾，或者从尾到头</strong>。 我们可以访问一个特定节点的下一个或前一个元素。</li><li>在单向链表中，如果迭代链表时错过了要找的元素，就需要回到链表起点，重新开始迭代。</li><li>在双向链表中，可以从任一节点，向前或向后迭代，这是双向链表的一个优点。</li><li>所以，双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</li></ul><h4 id="实现-4"><a href="#实现-4" class="headerlink" title="实现"></a>实现</h4><p>具体代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 创建双向链表 DoublyLinkedList 类</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">DoublyLinkedList</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Node</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">this</span>.element = element; <span class="hljs-comment">//当前节点的元素</span><br>    <span class="hljs-keyword">this</span>.next = <span class="hljs-literal">null</span>; <span class="hljs-comment">//下一个节点指针</span><br>    <span class="hljs-keyword">this</span>.previous = <span class="hljs-literal">null</span>; <span class="hljs-comment">//上一个节点指针</span><br>  &#125;<br><br>  <span class="hljs-keyword">var</span> length = <span class="hljs-number">0</span>; <span class="hljs-comment">// 链表长度</span><br>  <span class="hljs-keyword">var</span> head = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表头部</span><br>  <span class="hljs-keyword">var</span> tail = <span class="hljs-literal">null</span>; <span class="hljs-comment">// 链表尾部</span><br><br>  <span class="hljs-comment">// 向链表尾部添加一个新的项</span><br>  <span class="hljs-keyword">this</span>.append = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);<br>    <span class="hljs-keyword">var</span> currentNode = tail;<br><br>    <span class="hljs-comment">// 判断是否为空链表</span><br>    <span class="hljs-keyword">if</span> (currentNode === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-comment">// 空链表</span><br>      head = node;<br>      tail = node;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      currentNode.next = node;<br>      node.prev = currentNode;<br>      tail = node;<br>    &#125;<br><br>    length++;<br>  &#125;;<br><br>  <span class="hljs-comment">// 向链表特定位置插入一个新的项</span><br>  <span class="hljs-keyword">this</span>.insert = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">position, element</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt; length) &#123;<br>      <span class="hljs-comment">// 越界</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> node = <span class="hljs-keyword">new</span> Node(element);<br>      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">var</span> currentNode = head;<br>      <span class="hljs-keyword">var</span> previousNode;<br><br>      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (!head) &#123;<br>          head = node;<br>          tail = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          node.next = currentNode;<br>          currentNode.prev = node;<br>          head = node;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === length) &#123;<br>        <span class="hljs-keyword">this</span>.append(element);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (index &lt; position) &#123;<br>          index++;<br>          previousNode = currentNode;<br>          currentNode = currentNode.next;<br>        &#125;<br><br>        previousNode.next = node;<br>        node.next = currentNode;<br><br>        node.prev = previousNode;<br>        currentNode.prev = node;<br>      &#125;<br><br>      length++;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 从链表的特定位置移除一项</span><br>  <span class="hljs-keyword">this</span>.removeAt = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">position</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> ((position &lt; <span class="hljs-number">0</span> &amp;&amp; position &gt;= length) || length === <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 越界</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">var</span> currentNode = head;<br>      <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">var</span> previousNode;<br><br>      <span class="hljs-keyword">if</span> (position === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 移除第一项</span><br>        <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) &#123;<br>          head = <span class="hljs-literal">null</span>;<br>          tail = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          head = currentNode.next;<br>          head.prev = <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (position === length - <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-comment">// 移除最后一项</span><br>        <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) &#123;<br>          head = <span class="hljs-literal">null</span>;<br>          tail = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          currentNode = tail;<br>          tail = currentNode.prev;<br>          tail.next = <span class="hljs-literal">null</span>;<br>        &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">while</span> (index &lt; position) &#123;<br>          index++;<br>          previousNode = currentNode;<br>          currentNode = currentNode.next;<br>        &#125;<br>        previousNode.next = currentNode.next;<br>        previousNode = currentNode.next.prev;<br>      &#125;<br><br>      length--;<br><br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>  &#125;;<br><br>  <span class="hljs-comment">// 从链表中移除指定项</span><br>  <span class="hljs-keyword">this</span>.remove = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.indexOf(element);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.removeAt(index);<br>  &#125;;<br><br>  <span class="hljs-comment">// 返回元素在链表的索引，如果链表中没有该元素则返回 -1</span><br>  <span class="hljs-keyword">this</span>.indexOf = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> currentNode = head;<br>    <span class="hljs-keyword">var</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (currentNode) &#123;<br>      <span class="hljs-keyword">if</span> (currentNode.element === element) &#123;<br>        <span class="hljs-keyword">return</span> index;<br>      &#125;<br><br>      index++;<br>      currentNode = currentNode.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// 如果链表中不包含任何元素，返回 true ，如果链表长度大于 0 ，返回 false</span><br>  <span class="hljs-keyword">this</span>.isEmpty = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> length == <span class="hljs-number">0</span>;<br>  &#125;;<br><br>  <span class="hljs-comment">// 返回链表包含的元素个数，与数组的 length 属性类似</span><br>  <span class="hljs-keyword">this</span>.size = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> length;<br>  &#125;;<br><br>  <span class="hljs-comment">// 获取链表头部元素</span><br>  <span class="hljs-keyword">this</span>.getHead = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> head.element;<br>  &#125;;<br><br>  <span class="hljs-comment">// 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值</span><br>  <span class="hljs-keyword">this</span>.toString = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> currentNode = head;<br>    <span class="hljs-keyword">var</span> string = <span class="hljs-string">''</span>;<br><br>    <span class="hljs-keyword">while</span> (currentNode) &#123;<br>      string += <span class="hljs-string">','</span> + currentNode.element;<br>      currentNode = currentNode.next;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> string.slice(<span class="hljs-number">1</span>);<br>  &#125;;<br><br>  <span class="hljs-keyword">this</span>.print = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.toString());<br>  &#125;;<br><br>  <span class="hljs-comment">// 获取整个链表</span><br>  <span class="hljs-keyword">this</span>.list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'head: '</span>, head);<br>    <span class="hljs-keyword">return</span> head;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建双向链表</span><br>var doublyLinked = <span class="hljs-keyword">new</span> DoublyLinkedList();<br>console.<span class="hljs-built_in">log</span>(doublyLinked.isEmpty()); <span class="hljs-comment">// true</span><br>doublyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Tom'</span>);<br>doublyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Peter'</span>);<br>doublyLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Paul'</span>);<br>doublyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Tom,Peter,Paul"</span><br>doublyLinked.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'Susan'</span>);<br>doublyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Tom,Peter,Paul"</span><br>doublyLinked.insert(<span class="hljs-number">1</span>, <span class="hljs-string">'Jack'</span>);<br>doublyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Tom,Peter,Paul"</span><br>console.<span class="hljs-built_in">log</span>(doublyLinked.getHead()); <span class="hljs-comment">// "Susan"</span><br>console.<span class="hljs-built_in">log</span>(doublyLinked.isEmpty()); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(doublyLinked.indexOf(<span class="hljs-string">'Peter'</span>)); <span class="hljs-comment">// 3</span><br>console.<span class="hljs-built_in">log</span>(doublyLinked.indexOf(<span class="hljs-string">'Cris'</span>)); <span class="hljs-comment">// -1</span><br>doublyLinked.remove(<span class="hljs-string">'Tom'</span>);<br>doublyLinked.removeAt(<span class="hljs-number">2</span>);<br>doublyLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Paul"</span><br>doublyLinked.list(); <span class="hljs-comment">// 请看控制台输出</span><br></code></pre></td></tr></table></figure><p>整个链表数据在 JavaScript 里是怎样的呢 ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取整个链表</span><br>  <span class="hljs-keyword">this</span>.list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'head: '</span>, head);<br>    <span class="hljs-keyword">return</span> head;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>调用 doublyLinked.list(); .</p><p>控制台输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-16692def5ba7cd98.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="img"></p><p>链表代码实现的关键是弄清楚：前节点与后节点与边界。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p>循环链表是一种特殊的单链表。 循环链表和单链表相似，节点类型都是一样。 唯一的区别是，在创建循环链表的时候，让其<code>头节点的 next 属性指向它本身</code>。 即：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">head.next</span> = head<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这种行为会导致链表中每个节点的 next 属性都指向链表的头节点，换句话说，也就是<strong>链表的尾节点指向了头节点，形成了一个循环链表</strong>。如下图所示：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-9ec5e28b87d0d144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="循环链表"></p><p><strong>循环链表</strong>：在单链表的基础上，将尾节点的指针指向头结点，就构成了一个循环链表。环形链表从任意一个节点开始，都可以遍历整个链表。</p><p>代码：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs xquery">// 循环链表<br><span class="hljs-keyword">function</span> CircularLinkedList() &#123;<br>    // 节点<br>    <span class="hljs-keyword">function</span> Node(<span class="hljs-keyword">element</span>) &#123;<br>        this.<span class="hljs-keyword">element</span> = <span class="hljs-keyword">element</span>; // 当前节点的元素<br>        this.next = null; // 下一个节点指针<br>    &#125;<br><br>    var length = 0,<br>        head = null;<br><br>    this.append = function(<span class="hljs-keyword">element</span>) &#123;<br>        var <span class="hljs-type">node</span> = new Node(<span class="hljs-keyword">element</span>),<br>            current;<br><br>        if (!head) &#123;<br>           <span class="hljs-built_in"> head</span> = <span class="hljs-type">node</span>;<br>            // 头的指针指向自己<br>            <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            current =<span class="hljs-built_in"> head</span>;<br><br>            while (current.<span class="hljs-keyword">next</span> !==<span class="hljs-built_in"> head</span>) &#123;<br>                current = current.<span class="hljs-keyword">next</span>;<br>            &#125;<br><br>            current.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>            // 最后一个节点指向头节点<br>            <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>        &#125;<br><br>        length++;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;<br>    &#125;;<br><br>    this.<span class="hljs-keyword">insert</span> = <span class="hljs-keyword">function</span><span class="hljs-built_in">(position</span>, <span class="hljs-keyword">element</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(position</span> &gt; -<span class="hljs-number">1</span> &amp;&amp;<span class="hljs-built_in"> position</span> &lt; length) &#123;<br>            var <span class="hljs-type">node</span> = new Node(<span class="hljs-keyword">element</span>),<br>                index = 0,<br>                current = head,<br>                previous;<br><br>            if (position === 0) &#123;<br>                // 头节点指向自己<br>                <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>               <span class="hljs-built_in"> head</span> = <span class="hljs-type">node</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                while (index++ &lt;<span class="hljs-built_in"> position</span>) &#123;<br>                    <span class="hljs-keyword">previous</span> = current;<br>                    current = current.<span class="hljs-keyword">next</span>;<br>                &#125;<br>                <span class="hljs-keyword">previous</span>.<span class="hljs-keyword">next</span> = <span class="hljs-type">node</span>;<br>                <span class="hljs-type">node</span>.<span class="hljs-keyword">next</span> = current;<br>            &#125;<br>            length++;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;<br>        &#125;<br>    &#125;;<br>    this.removeAt = <span class="hljs-keyword">function</span><span class="hljs-built_in">(position</span>) &#123;<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">(position</span> &gt; -<span class="hljs-number">1</span> &amp;&amp;<span class="hljs-built_in"> position</span> &lt; length) &#123;<br>            var current =<span class="hljs-built_in"> head</span>,<br>                <span class="hljs-keyword">previous</span>,<br>                index = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">(position</span> === <span class="hljs-number">0</span>) &#123;<br>               <span class="hljs-built_in"> head</span> = current.<span class="hljs-keyword">next</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                while (index++ &lt;<span class="hljs-built_in"> position</span>) &#123;<br>                    <span class="hljs-keyword">previous</span> = current;<br>                    current = current.<span class="hljs-keyword">next</span>;<br>                &#125;<br>                <span class="hljs-keyword">previous</span>.<span class="hljs-keyword">next</span> = current.<span class="hljs-keyword">next</span>;<br>            &#125;<br>            length--;<br>            <span class="hljs-keyword">return</span> current.<span class="hljs-keyword">element</span>;<br>        &#125; else &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;<br>        &#125;<br>    &#125;;<br>    this<span class="hljs-built_in">.remove</span> = <span class="hljs-keyword">function</span>(<span class="hljs-keyword">element</span>) &#123;<br>        var current =<span class="hljs-built_in"> head</span>,<br>            <span class="hljs-keyword">previous</span>,<br>            indexCheck = <span class="hljs-number">0</span>;<br>        while (current &amp;&amp; indexCheck &lt; length) &#123;<br>            <span class="hljs-keyword">if</span> (current.<span class="hljs-keyword">element</span> === <span class="hljs-keyword">element</span>) &#123;<br>                <span class="hljs-keyword">if</span> (indexCheck == <span class="hljs-number">0</span>) &#123;<br>                   <span class="hljs-built_in"> head</span> = current.<span class="hljs-keyword">next</span>;<br>                    length--;<br>                    <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">previous</span>.<span class="hljs-keyword">next</span> = current.<span class="hljs-keyword">next</span>;<br>                    length--;<br>                    <span class="hljs-keyword">return</span><span class="hljs-built_in"> true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">previous</span> = current;<br>                current = current.<span class="hljs-keyword">next</span>;<br>                indexCheck++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;<br>    &#125;;<br>    this<span class="hljs-built_in">.remove</span> = <span class="hljs-keyword">function</span>() &#123;<br>        <span class="hljs-keyword">if</span> (length === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-built_in"> false</span>;<br>        &#125;<br>        var current =<span class="hljs-built_in"> head</span>,<br>            <span class="hljs-keyword">previous</span>,<br>            indexCheck = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span>) &#123;<br>           <span class="hljs-built_in"> head</span> = null;<br>            length--;<br>            <span class="hljs-keyword">return</span> current.<span class="hljs-keyword">element</span>;<br>        &#125;<br>        while (indexCheck++ &lt; length) &#123;<br>            <span class="hljs-keyword">previous</span> = current;<br>            current = current.<span class="hljs-keyword">next</span>;<br>        &#125;<br>        <span class="hljs-keyword">previous</span>.<span class="hljs-keyword">next</span> =<span class="hljs-built_in"> head</span>;<br>        length--;<br>        <span class="hljs-keyword">return</span> current.<span class="hljs-keyword">element</span>;<br>    &#125;;<br>    this.indexOf = function(<span class="hljs-keyword">element</span>) &#123;<br>        var current =<span class="hljs-built_in"> head</span>,<br>            index = <span class="hljs-number">0</span>;<br>        while (current &amp;&amp; index &lt; length) &#123;<br>            <span class="hljs-keyword">if</span> (current.<span class="hljs-keyword">element</span> === <span class="hljs-keyword">element</span>) &#123;<br>                <span class="hljs-keyword">return</span> index;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                index++;<br>                current = current.<span class="hljs-keyword">next</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;;<br>    this.isEmpty = <span class="hljs-keyword">function</span>() &#123;<br>        <span class="hljs-keyword">return</span> length === <span class="hljs-number">0</span>;<br>    &#125;;<br>    this.size = <span class="hljs-keyword">function</span>() &#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;;<br><br>    // 由于链表使用了 Node 类，就需要重写继承自 JavaScript 对象默认的 toString() 方法，让其只输出元素的值<br>    this.toString = <span class="hljs-keyword">function</span>() &#123;<br>        var current =<span class="hljs-built_in"> head</span>,<br>           <span class="hljs-built_in"> string</span> = <span class="hljs-string">''</span>,<br>            indexCheck = <span class="hljs-number">0</span>;<br>        while (current &amp;&amp; indexCheck &lt; length) &#123;<br>           <span class="hljs-built_in"> string</span> += <span class="hljs-string">','</span> + current.<span class="hljs-keyword">element</span>;<br>            current = current.next;<br>            indexCheck++;<br>        &#125;<br>        return string.slice(1);<br>    &#125;;<br><br>    // 获取链表头部元素<br>    this.getHead = function() &#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>.<span class="hljs-keyword">element</span>;<br>    &#125;;<br><br>    // 打印链表数据<br>    this.print = function() &#123;<br>        console.log(this.toString());<br>    &#125;;<br><br>    // 获取整个链表<br>    this.list = <span class="hljs-keyword">function</span>() &#123;<br>        console.log(<span class="hljs-string">'head: '</span>,<span class="hljs-built_in"> head</span>);<br>        <span class="hljs-keyword">return</span><span class="hljs-built_in"> head</span>;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 创建单向链表实例</span><br>var circularLinked = <span class="hljs-keyword">new</span> CircularLinkedList();<br>console.<span class="hljs-built_in">log</span>(circularLinked.removeAt(<span class="hljs-number">0</span>)); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(circularLinked.isEmpty()); <span class="hljs-comment">// true</span><br>circularLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Tom'</span>);<br>circularLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Peter'</span>);<br>circularLinked.<span class="hljs-built_in">append</span>(<span class="hljs-string">'Paul'</span>);<br>circularLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Tom,Peter,Paul"</span><br>circularLinked.insert(<span class="hljs-number">0</span>, <span class="hljs-string">'Susan'</span>);<br>circularLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Tom,Peter,Paul"</span><br>circularLinked.insert(<span class="hljs-number">1</span>, <span class="hljs-string">'Jack'</span>);<br>circularLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Tom,Peter,Paul"</span><br>console.<span class="hljs-built_in">log</span>(circularLinked.getHead()); <span class="hljs-comment">// "Susan"</span><br>console.<span class="hljs-built_in">log</span>(circularLinked.isEmpty()); <span class="hljs-comment">// false</span><br>console.<span class="hljs-built_in">log</span>(circularLinked.indexOf(<span class="hljs-string">'Peter'</span>)); <span class="hljs-comment">// 3</span><br>console.<span class="hljs-built_in">log</span>(circularLinked.indexOf(<span class="hljs-string">'Cris'</span>)); <span class="hljs-comment">// -1</span><br>circularLinked.remove(<span class="hljs-string">'Tom'</span>);<br>circularLinked.removeAt(<span class="hljs-number">2</span>);<br>circularLinked.<span class="hljs-built_in">print</span>(); <span class="hljs-comment">// "Susan,Jack,Paul"</span><br>circularLinked.list(); <span class="hljs-comment">// 具体控制台</span><br></code></pre></td></tr></table></figure><p>整个链表数据在 JavaScript 里是怎样的呢 ？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 获取整个链表</span><br>  <span class="hljs-keyword">this</span>.list = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'head: '</span>, head);<br>    <span class="hljs-keyword">return</span> head;<br>  &#125;;<br></code></pre></td></tr></table></figure><p>调用 circularLinked.list() 。</p><p>控制台输出如下：</p><p><img src="https://upload-images.jianshu.io/upload_images/12890819-b91c5f932a9ffba5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" srcset="/img/loading.gif" alt="img"></p><p>你知道大家发现没有，为什么从 1 - 4 - 1 了，还有 next 节点，而且是还可以一直点 next ，重复的展开下去，这正是 <strong>循环</strong> 的原因。</p><p><strong>链表总结</strong></p><ul><li>写链表代码是最考验逻辑思维能力的，要熟练链表，只有 <strong>多写多练，没有捷径</strong>。</li><li>因为，链表代码到处都是指针的操作、边界条件的处理，稍有不慎就容易产生 Bug。</li><li>链表代码写得好坏，可以看出一个人写代码是否够细心，考虑问题是否全面，思维是否缜密。</li><li>所以，这也是很多面试官喜欢让人手写链表代码的原因。</li><li>一定要自己写代码实现一下，才有效果。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>数据结构</tag>
      
      <tag>线性表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浏览器访问</title>
    <link href="/2018/09/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE/"/>
    <url>/2018/09/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器访问过程"><a href="#浏览器访问过程" class="headerlink" title="浏览器访问过程"></a>浏览器访问过程</h1><p>假设你用一个全新的浏览器（第一次启动的那种），访问百度（<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com">http://www.baidu.com/</a>），在你敲入网址并按下回车之后，将会发生以下神奇的事情：</p><p>浏览器先尝试从Host文件中获取<a href="https://link.zhihu.com/?target=http%3A//www.baidu.com">http://www.baidu.com/</a>对应的IP地址，如果能取到当然万事大吉大家都能嗨，如果不能，就使用DNS协议来获取IP咯。</p><blockquote><p>在DNS协议中，PC会向你的本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到百度的IP，得到就好，得不到还得向更高层次的DNS服务器求助，最终总能得到百度的IP。</p></blockquote><p>得到百度的IP，下一步是使用TCP协议，建立TCP连接。</p><blockquote><p>在TCP协议中，建立TCP需要与百度服务器握手三次，你先告诉服务器你要给服务器发东西（SYN），服务器应答你并告诉你它也要给你发东西（SYN、ACK），然后你应答服务器（ACK），总共来回了3次，称为3次握手。</p></blockquote><p>不过，建立TCP连接有个前提（或者说给服务器发消息有个前提）：你必须能成功地把消息发到服务器上。虽然已经知道IP，但并无啥用（比如说，你在广东，你知道北京的地理坐标经纬度就能到北京了？你得知道有哪些路通往北京吧你得准备盘缠吧你得花时间吧）。</p><p>为了将消息从你的PC上传到服务器上，需要用到IP协议、ARP协议和OSPF协议。</p><blockquote><p>我们都知道，你的PC和百度服务器之间一般会有许多路由器之类的东西，IP协议指定了出发地（你的PC）和目的地（服务器）；你的数据会经过一个又一个路由器，OSPF决定了会经过那些路由器（用一种叫路由算法的玩意，找出最佳路径）；从一个路由器怎么传给下一个路由器？这是ARP协议的JOB，ARP负责求下一个节点的地址（我们不止是要目的地，还要中间节点的地址）。<br>IP协议使用的是IP地址，整个发送过程中只涉及出发地和目的地2个IP地址，而ARP协议使用的是MAC地址，整个发送过程中涉及到每一个节点的MAP地址</p></blockquote><p>现在，我们能和服务器通信，还建立了TCP连接，下一步干嘛，当然是用HTTP协议请求网页内容咯。</p><blockquote><p>你发个HTTP请求报文给服务器，如果服务器禁止你访问它就给你回个”Forbidden”，如果它暂时挂掉了就给你回个“内部服务错误”，如果它正常才给你回个“OK“并将你要的数据传给你；如果你还需要其它的东西再去跟它要（它一般还会给你的-_-）。</p></blockquote><p>你收到了服务器的回复，是一坨HTML形式的文本。浏览器必须要能够理解文本的内容，并快速地渲染到屏幕上（浏览器一般用有限自动机来理解文本内容，渲染的话就各看本事了，之所以微软IE卡成狗而谷歌浏览器很6，就是它们的渲染速度不同…）</p><p>渲染出来后，你就看到百度的首页了</p><p><img src="https://pic3.zhimg.com/50/1691d818f85e0d9f6be15d48e2debe1b_hd.jpg" srcset="/img/loading.gif" alt="img"></p><blockquote><p>作者：邱永臣<br>链接：<a href="https://www.zhihu.com/question/20513729/answer/96332435" target="_blank" rel="noopener">https://www.zhihu.com/question/20513729/answer/96332435</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript的出现</title>
    <link href="/2018/09/18/JavaScript%E7%9A%84%E5%87%BA%E7%8E%B0/"/>
    <url>/2018/09/18/JavaScript%E7%9A%84%E5%87%BA%E7%8E%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="JavaScript的出现"><a href="#JavaScript的出现" class="headerlink" title="JavaScript的出现"></a>JavaScript的出现</h1><ul><li>简单的历史背景<ul><li>JavaScript语言本身是为了解决90年代初期，差网速条件下的表单验证而生。这么说可能不够形象，我举个例子：在90年初的某一个晚上，你看到某个论坛的内容十分吸引人，然后点击了注册，输入了信息后有个提交，点击提交，接下来的半分钟甚至1~2分钟内，你都将看到的时候那个永无休止的圆圈再转！那是多么的痛苦！那时的表单验证就是这样，52kb的网速，加上往返的验证、request等等，如果是现在，估计10秒的不响应你都会刷新重来，或者认为网络、网页出了问题！因此，Netscape Navigation公司组织研发了livescript脚本语言应对此问题，又恰逢当时编程语言的爆发，Java语言同时期更早一点发布，Netscape Navigation公司匆忙地将livescript脚本语言发布，并搭上Java语言的热潮改名为Javascript语言，实际两者并没有什么关系！至此还有很多人在交流时这样说<br>“你学的什么语言啊?””javascript””你学的Java啊！””/晕”！可谓这个顺风车搭的非常有效果！</li><li>虽然JavaScript的开发非常成功，但是迫于那个浏览器动荡的时代，JavaScript也不得不想ECMA求助，终于，在92年期间，以JavaScript1.1版本向ECMA提交建议，开发出一套通用的、跨品台供应商中立的标准脚本语言。次年，ISO/IEC等也采取了ECMA的js标准。至此，ECMAScript诞生，所以所说的js不是js，js又是js，JavaScript和ECMAscript互相包容，互相依赖，用<a href="http://developer.51cto.com/art/201711/557514.htm" target="_blank" rel="noopener">一文读懂JavaScript和ECMAscript的区别</a>上的一句话来说：</li></ul></li></ul><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">ECMAScript 是基于 <span class="hljs-keyword">JavaScript </span>的，而同时 <span class="hljs-keyword">JavaScript </span>又是基于ECMAScript 的。<br>就像是一个人穿越变成了自己的父母一样——有点矛盾，不过想起来还是挺搞笑的。<br></code></pre></td></tr></table></figure><ul><li><p>JavaScript的实现</p><ul><li>说来JavaScript还是一门服务于浏览器和网页的脚本语言，而一个完整的JavaScript语言的实现由以下三个不同的部分组成。<ul><li>核心(ECMAsrcipt);</li><li>文档对象模型(DOM);</li><li>浏览器对象模型(BOM);</li></ul></li><li>一门标准的JavaScript语言规定了哪些内容呢？<ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul></li></ul></li><li><p>DOM级别</p><ul><li>DOM2：DOM视图、DOM事件、DOM样式、DOM遍历和范围</li><li>DOM3：新增了DOM验证方法、开放支持XML（我觉得将来有一天真的有可能会将HTML发展成XML，并得到良好支持！）</li></ul></li><li><p>浏览器对象模型(BOM)</p><ul><li><p>弹出窗口功能</p></li><li><p>移动缩放和关闭浏览器功能</p></li><li><p>提供浏览器详细信息的navigation对象</p></li><li><p>提供浏览器加载页面详细信息的locating对象</p></li><li><p>提供用户显示器分辨率详细的screen对象</p></li><li><p>对cookies的支持</p></li><li><p>类似xmlhttp Request和IE的action Xobject</p></li><li><p>这样的自定义对象</p><h1 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h1></li></ul></li><li><p>script元素引用</p><ul><li><p>在<head>头部等文档位置引用</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js/javacript.js"</span>&gt;</span><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">scrit</span>&gt;</span></span></span><br></code></pre></td></tr></table></figure></li><li><p>在文档内任意元素间插入小块脚本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="actionscript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>&#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"hello world!"</span>)</span><br>    &#125;<br><span class="handlebars"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span></span></span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>使用文档内js脚本和引用脚本时应该注意的地方</p><ul><li>加载顺序<br>文档流默认从上至下加载，如果js放在head头部，那么网页在加载之前要先等待js脚本加载并执行完毕后才能加载后面body的内容或者后面的其他内容，显然这样会影响网页的内容加载速度！</li><li><script></script>标签匹配原则里，默认<script>标签会匹配最近的</script>标签，如下，第一个<script>标签会匹配alert里的那个</script>标签，故引起报错：</li></ul></li></ul><table><thead><tr><th align="center">代码</th><th align="center">输出</th></tr></thead><tbody><tr><td align="center">‘</td><td align="center">单引号</td></tr><tr><td align="center">“</td><td align="center">双引号</td></tr><tr><td align="center">&amp;</td><td align="center">和、与</td></tr><tr><td align="center"></td><td align="center">反斜杠</td></tr><tr><td align="center">n</td><td align="center">换行符</td></tr><tr><td align="center">r</td><td align="center">回车符</td></tr><tr><td align="center">t</td><td align="center">制表符</td></tr><tr><td align="center">b</td><td align="center">退格符</td></tr><tr><td align="center">f</td><td align="center">换页符</td></tr></tbody></table><p>或者用实体参考：<a href="http://www.runoob.com/charsets/ref-html-entities-4.html" target="_blank" rel="noopener">去这里查看完整版</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>JacaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Css</title>
    <link href="/2018/09/15/Css/"/>
    <url>/2018/09/15/Css/</url>
    
    <content type="html"><![CDATA[<h1 id="Css"><a href="#Css" class="headerlink" title="Css"></a>Css</h1><p>标签样式，目前讲究标签样式分离，所以展示效果都加在Css上。</p><h1 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h1><h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>正常的布局流（在布局介绍文章中提到）是将元素放置在浏览器视口内的系统。<br>默认情况下，<br>块级元素在视口中垂直布局——每个都将显示在上一个元素下面的新行上，并且它们的外边距将分隔开它们。<br>内联元素互相之间以及任何相邻（或被包裹）的文本内容位于同一行上，只要在父块级元素的宽度内有空间可以这样做。<br><code>如果两个相邻元素都在其上设置外边距，并且两个外边距接触，则两个外边距中的较大者保留，较小的一个消失——这叫外边距折叠</code></p><h2 id="position"><a href="#position" class="headerlink" title="position"></a>position</h2><p><strong>静态定位（元素在文档流中的正常位置）</strong><br>position：absolute；（默认值）<br><strong>相对定位（占据正常文档六中的位置）</strong><br>position：relative；<br>使用top, bottom, left, 和 right 来精确指定要将定位元素移动到的位置。（相对于元素移动之前的位置）。<br><strong>绝对定位（元素脱离正常文档流）</strong><br>绝对定位自己的层独立于一切。这是非常有用的——这意味着我们可以创建不干扰页面上其他元素的位置的隔离的UI功能 ——例如弹出信息框和控制菜单，翻转面板，可以在页面上的任何地方拖放的UI功能等。<br>使用top, bottom, left, 和 right 来精确指定要将定位元素移动到的位置。（相对于包含元素的位置）。<br>给绝对定位的元素设置top: 0; bottom: 0; left: 0; right: 0; 和 margin: 0;会使元素布满整个可视窗口</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs clean">###### 定位上下文<br>改变定位上下文——绝对定位的元素相对于其定位的元素，是通过在元素的其他祖先之一上设置定位（position：relative；）来实现的——它是嵌套在其中的元素之一。<br>###### z-index<br>使用z-index属性改变堆叠顺序。<br>例：z-index：<span class="hljs-number">1</span>；（值越大级别越高，越靠上）<br>**固定定位（脱离文档流）**<br>与绝对定位的工作方式完全相同，只有一个主要区别——绝对定位固定元素是相对于 `&lt;html&gt;` 元素或其最近的定位祖先，而固定定位固定元素则是相对于浏览器视口本身。 这意味着您可以创建固定的有用的UI项目，如持久导航菜单。<br></code></pre></td></tr></table></figure><h1 id="弹性盒子（Flex）"><a href="#弹性盒子（Flex）" class="headerlink" title="弹性盒子（Flex）"></a>弹性盒子（Flex）</h1><p>在需要设置为柔性的盒子的父元素中设置display：flex；</p><h3 id="模型说明"><a href="#模型说明" class="headerlink" title="模型说明"></a>模型说明</h3><p>当元素表现为flex框时，他们沿着两个轴来布局：<br><img src="https://developer.mozilla.org/files/3739/flex_terms.png" srcset="/img/loading.gif" alt="img"><br>主轴（main axis）是沿着flex元素放置的方向延伸的轴。该轴的开始和结束被称为main start和main end。<br>交叉轴（cross axis）是垂直于flex元素防止方向的轴。该轴的开始和结束被称为cross start和cross end。<br>设置了display：flex的元素被称为flex容器（flex container）<br>在flex容器中表现为柔性的盒子的元素被称为flex项。</p><h3 id="容器属性"><a href="#容器属性" class="headerlink" title="容器属性"></a>容器属性</h3><h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p>用于指定主轴的方向。可取值为：<br>·row：默认值，主轴为水平方向，起点在左端<br>·row-reverse：主轴为水平方向，起点在右端<br>·column：主轴为垂直方向，起点在上沿<br>·column-reverse：主轴为垂直方向，起点在下沿<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071005.png" srcset="/img/loading.gif" alt="img"></p><h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p>档在布局中使用定宽或者定高的时候，一行中的元素过多，很有可能会溢出，破坏布局。可取值为：<br>·nowrap：（默认）不换行<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071007.png" srcset="/img/loading.gif" alt="img"><br>·wrap：换行，第一行在上方<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071008.jpg" srcset="/img/loading.gif" alt="img"><br>·wrap-reverse：换行，第一行在下方<br><img src="http://www.ruanyifeng.com/blogimg/asset/2015/bg2015071009.jpg" srcset="/img/loading.gif" alt="img"></p><h4 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h4><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为：row nowrap</p><h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p>定义项目在主轴上的对齐方式。可取值为：<br>flex-start：左对齐（默认值）<br>flex-end：右对齐<br>center：居中<br>space-between：两端对齐，项目之间间隔相等<br>space-around：每个项目两侧的间隔相等<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/c55dfe8e3422458b50e985552ef13ba5.png" srcset="/img/loading.gif" alt="img"></p><h4 id="align-item"><a href="#align-item" class="headerlink" title="align-item"></a>align-item</h4><p>定义项目在交叉轴上的对齐方式<br>flex-start：交叉轴起点对齐<br>flex-end：交叉轴终点对齐<br>center：交叉轴中点对齐<br>stretch（默认值）：如果项目没有设置高度或设为auto，将占满整个容器的高度<br>baseline：项目的第一行文字的基线对齐<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/2b0c39c7e7a80d5a784c8c2ca63cde17.png" srcset="/img/loading.gif" alt="img"></p><h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p>定义多轴线对齐方式，如果项目只有一根轴线，该属性不起作用。<br>flex-start：与交叉轴起点对齐<br>flex-end：与交叉轴终点对齐<br>center：与交叉轴中点对齐<br>stretch：轴线占满整个交叉轴<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布<br>space-around：没跟轴线两侧的间隔都相等<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/f10918ccb8a13247c9d47715a2bd2c33.png" srcset="/img/loading.gif" alt="img"></p><h3 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p>定义项目的排列顺序，数值越小，排列越靠前<br>order：number；</p><h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p>定义项目的放大比例，默认值为0，即如果存在是剩余空间，也不放大。<br>flex-grow:number;<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/f41c08bb35962ed79e7686f735d6cd78.png" srcset="/img/loading.gif" alt="img"><br>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>定义项目的缩小比例，默认值为1，即如果空间不足，项目缩小。<br>flex-shrink:number;<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/240d3e960043a729bb3ff5e34987904f.jpg" srcset="/img/loading.gif" alt="img"><br>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>定义在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。默认值为auto，即项目本来的大小。可以设置为跟width和height属性一样的值，即项目占据固定空间。</p><h4 id="flex属性"><a href="#flex属性" class="headerlink" title="flex属性"></a>flex属性</h4><p>是flex-grow，flex-shrink和flex-basis的缩写，默认值为0，1，auto。</p><h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p>允许单个项目有与其他项目不一样的对齐方式，可覆盖align-item值，默认为auto，表示继承父元素的align-item属性，如果没有父元素，则等同于stretch。<br><img src="http://www.runoob.com/wp-content/uploads/2015/07/55b19171b8b6b9487d717bf2ecbba6de.png" srcset="/img/loading.gif" alt="img"><br>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p><h1 id="Grid"><a href="#Grid" class="headerlink" title="Grid"></a>Grid</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>网格布局（Grid）是最强大的 CSS 布局方案。</p><p>它将网页划分成一个个网格，可以任意组合不同的网格，做出各种各样的布局。以前，只能通过复杂的 CSS 框架达到的效果，现在浏览器内置了。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032501.png" srcset="/img/loading.gif" alt="img"></p><p>上图这样的布局，就是 Grid 布局的拿手好戏。</p><p>Grid 布局与 <a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局</a>有一定的相似性，都可以指定容器内部多个项目的位置。但是，它们也存在重大区别。</p><p>Flex 布局是轴线布局，只能指定”项目”针对轴线的位置，可以看作是<strong>一维布局</strong>。Grid 布局则是将容器划分成”行”和”列”，产生单元格，然后指定”项目所在”的单元格，可以看作是<strong>二维布局</strong>。Grid 布局远比 Flex 布局强大。</p><h2 id="二、基本概念"><a href="#二、基本概念" class="headerlink" title="二、基本概念"></a>二、基本概念</h2><p>学习 Grid 布局之前，需要了解一些基本概念。</p><h3 id="2-1-容器和项目"><a href="#2-1-容器和项目" class="headerlink" title="2.1 容器和项目"></a>2.1 容器和项目</h3><p>采用网格布局的区域，称为”容器”（container）。容器内部采用网格定位的子元素，称为”项目”（item）。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markup">&lt;div&gt;<br>  &lt;div&gt;&lt;p&gt;1&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;<br>  &lt;div&gt;&lt;p&gt;2&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;<br>  &lt;div&gt;&lt;p&gt;3&lt;&#x2F;p&gt;&lt;&#x2F;div&gt;<br>&lt;&#x2F;div&gt;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，最外层的<code>元素就是容器，内层的三个</code>元素就是项目。</p><p>注意：项目只能是容器的顶层子元素，不包含项目的子元素，比如上面代码的``元素就不是项目。Grid 布局只对项目生效。</p><h3 id="2-2-行和列"><a href="#2-2-行和列" class="headerlink" title="2.2 行和列"></a>2.2 行和列</h3><p>容器里面的水平区域称为”行”（row），垂直区域称为”列”（column）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032502.png" srcset="/img/loading.gif" alt="img"></p><p>上图中，水平的深色区域就是”行”，垂直的深色区域就是”列”。</p><h3 id="2-3-单元格"><a href="#2-3-单元格" class="headerlink" title="2.3 单元格"></a>2.3 单元格</h3><p>行和列的交叉区域，称为”单元格”（cell）。</p><p>正常情况下，<code>n</code>行和<code>m</code>列会产生<code>n x m</code>个单元格。比如，3行3列会产生9个单元格。</p><h3 id="2-4-网格线"><a href="#2-4-网格线" class="headerlink" title="2.4 网格线"></a>2.4 网格线</h3><p>划分网格的线，称为”网格线”（grid line）。水平网格线划分出行，垂直网格线划分出列。</p><p>正常情况下，<code>n</code>行有<code>n + 1</code>根水平网格线，<code>m</code>列有<code>m + 1</code>根垂直网格线，比如三行就有四根水平网格线。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032503.png" srcset="/img/loading.gif" alt="img"></p><p>上图是一个 4 x 4 的网格，共有5根水平网格线和5根垂直网格线。</p><h2 id="三、容器属性"><a href="#三、容器属性" class="headerlink" title="三、容器属性"></a>三、容器属性</h2><p>Grid 布局的属性分成两类。一类定义在容器上面，称为容器属性；另一类定义在项目上面，称为项目属性。这部分先介绍容器属性。</p><h3 id="3-1-display-属性"><a href="#3-1-display-属性" class="headerlink" title="3.1 display 属性"></a>3.1 display 属性</h3><p><code>display: grid</code>指定一个容器采用网格布局。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032504.png" srcset="/img/loading.gif" alt="img"></p><p>上图是<code>display: grid</code>的<a href="https://jsbin.com/guvivum/edit?html,css,output" target="_blank" rel="noopener">效果</a>。</p><p>默认情况下，容器元素都是块级元素，但也可以设成行内元素。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">display</span>: inline-grid;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码指定<code>div</code>是一个行内元素，该元素内部采用网格布局。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032505.png" srcset="/img/loading.gif" alt="img"></p><p>上图是<code>display: inline-grid</code>的<a href="https://jsbin.com/qatitav/edit?html,css,output" target="_blank" rel="noopener">效果</a>。</p><blockquote><p>注意，设为网格布局以后，容器子元素（项目）的<code>float</code>、<code>display: inline-block</code>、<code>display: table-cell</code>、<code>vertical-align</code>和<code>column-*</code>等设置都将失效。</p></blockquote><h3 id="3-2-grid-template-columns-属性，-grid-template-rows-属性"><a href="#3-2-grid-template-columns-属性，-grid-template-rows-属性" class="headerlink" title="3.2 grid-template-columns 属性， grid-template-rows 属性"></a>3.2 grid-template-columns 属性， grid-template-rows 属性</h3><p>容器指定了网格布局以后，接着就要划分行和列。<code>grid-template-columns</code>属性定义每一列的列宽，<code>grid-template-rows</code>属性定义每一行的行高。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/qiginur/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定了一个三行三列的网格，列宽和行高都是<code>100px</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" srcset="/img/loading.gif" alt="img"></p><p>除了使用绝对单位，也可以使用百分比。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span> <span class="hljs-number">33.33%</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><strong>（1）repeat()</strong></p><p>有时候，重复写同样的值非常麻烦，尤其网格很多时。这时，可以使用<code>repeat()</code>函数，简化重复的值。上面的代码用<code>repeat()</code>改写如下。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-built_in">repeat</span>(<span class="hljs-number">3</span>, <span class="hljs-number">33.33%</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><code>repeat()</code>接受两个参数，第一个参数是重复的次数（上例是3），第二个参数是所要重复的值。</p><p><code>repeat()</code>重复某种模式也是可以的。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-columns</span>: <span class="hljs-selector-tag">repeat</span>(2, 100<span class="hljs-selector-tag">px</span> 20<span class="hljs-selector-tag">px</span> 80<span class="hljs-selector-tag">px</span>);<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/cokohu/edit?css,output" target="_blank" rel="noopener">上面代码</a>定义了6列，第一列和第四列的宽度为<code>100px</code>，第二列和第五列为<code>20px</code>，第三列和第六列为<code>80px</code>。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032507.png" srcset="/img/loading.gif" alt="img"></p><p><strong>（2）auto-fill 关键字</strong></p><p>有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用<code>auto-fill</code>关键字表示自动填充。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-built_in">repeat</span>(auto-fill, <span class="hljs-number">100px</span>);<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/himoku/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示每列宽度<code>100px</code>，然后自动填充，直到容器不能放置更多的列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032508.png" srcset="/img/loading.gif" alt="img"></p><p><strong>（3）fr 关键字</strong></p><p>为了方便表示比例关系，网格布局提供了<code>fr</code>关键字（fraction 的缩写，意为”片段”）。如果两列的宽度分别为<code>1fr</code>和<code>2fr</code>，就表示后者是前者的两倍。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">1</span>fr <span class="hljs-number">1</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/hadexek/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示两个相同宽度的列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/1_bg2019032509.png" srcset="/img/loading.gif" alt="img"></p><p><code>fr</code>可以与绝对长度的单位结合使用，这时会非常方便。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">150px</span> <span class="hljs-number">1</span>fr <span class="hljs-number">2</span>fr;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/remowec/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032510.png" srcset="/img/loading.gif" alt="img"></p><p><strong>（4）minmax()</strong></p><p><code>minmax()</code>函数产生一个长度范围，表示长度就在这个范围之中。它接受两个参数，分别为最小值和最大值。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-columns</span>: 1<span class="hljs-selector-tag">fr</span> 1<span class="hljs-selector-tag">fr</span> <span class="hljs-selector-tag">minmax</span>(100<span class="hljs-selector-tag">px</span>, 1<span class="hljs-selector-tag">fr</span>);<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，<code>minmax(100px, 1fr)</code>表示列宽不小于<code>100px</code>，不大于<code>1fr</code>。</p><p><strong>（5）auto 关键字</strong></p><p><code>auto</code>关键字表示由浏览器自己决定长度。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-columns</span>: 100<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">auto</span> 100<span class="hljs-selector-tag">px</span>;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，第二列的宽度，基本上等于该列单元格的最大宽度，除非单元格内容设置了<code>min-width</code>，且这个值大于最大宽度。</p><p><strong>（6）网格线的名称</strong></p><p><code>grid-template-columns</code>属性和<code>grid-template-rows</code>属性里面，还可以使用方括号，指定每一根网格线的名字，方便以后的引用。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: [c1] <span class="hljs-number">100px</span> [c2] <span class="hljs-number">100px</span> [c3] auto [c4];<br>  <span class="hljs-attribute">grid-template-rows</span>: [r1] <span class="hljs-number">100px</span> [r2] <span class="hljs-number">100px</span> [r3] auto [r4];<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码指定网格布局为3行 x 3列，因此有4根垂直网格线和4根水平网格线。方括号里面依次是这八根线的名字。</p><p>网格布局允许同一根线有多个名字，比如<code>[fifth-line row-5]</code>。</p><p><strong>（7）布局实例</strong></p><p><code>grid-template-columns</code>属性对于网页布局非常有用。两栏式布局只需要一行代码。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">70%</span> <span class="hljs-number">30%</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码将左边栏设为70%，右边栏设为30%。</p><p>传统的十二网格布局，写起来也很容易。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-columns</span>: <span class="hljs-selector-tag">repeat</span>(12, 1<span class="hljs-selector-tag">fr</span>);<br></code></pre></td></tr></table></figure></blockquote><h3 id="3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性"><a href="#3-3-grid-row-gap-属性，-grid-column-gap-属性，-grid-gap-属性" class="headerlink" title="3.3 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性"></a>3.3 grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性</h3><p><code>grid-row-gap</code>属性设置行与行的间隔（行间距），<code>grid-column-gap</code>属性设置列与列的间隔（列间距）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-row-gap</span>: <span class="hljs-number">20px</span>;<br>  <span class="hljs-attribute">grid-column-gap</span>: <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/mezufab/edit?css,output" target="_blank" rel="noopener">上面代码</a>中，<code>grid-row-gap</code>用于设置行间距，<code>grid-column-gap</code>用于设置列间距。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032511.png" srcset="/img/loading.gif" alt="img"></p><p><code>grid-gap</code>属性是<code>grid-column-gap</code>和<code>grid-row-gap</code>的合并简写形式，语法如下。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-gap</span>: &lt;<span class="hljs-selector-tag">grid-row-gap</span>&gt; &lt;<span class="hljs-selector-tag">grid-column-gap</span>&gt;;<br></code></pre></td></tr></table></figure></blockquote><p>因此，上面一段 CSS 代码等同于下面的代码。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">grid-gap</span>: <span class="hljs-number">20px</span> <span class="hljs-number">20px</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>如果<code>grid-gap</code>省略了第二个值，浏览器认为第二个值等于第一个值。</p><blockquote><p>根据最新标准，上面三个属性名的<code>grid-</code>前缀已经删除，<code>grid-column-gap</code>和<code>grid-row-gap</code>写成<code>column-gap</code>和<code>row-gap</code>，<code>grid-gap</code>写成<code>gap</code>。</p></blockquote><h3 id="3-4-grid-template-areas-属性"><a href="#3-4-grid-template-areas-属性" class="headerlink" title="3.4 grid-template-areas 属性"></a>3.4 grid-template-areas 属性</h3><p>网格布局允许指定”区域”（area），一个区域由单个或多个单元格组成。<code>grid-template-areas</code>属性用于定义区域。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-areas</span>: <span class="hljs-string">'a b c'</span><br>                       <span class="hljs-string">'d e f'</span><br>                       <span class="hljs-string">'g h i'</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码先划分出9个单元格，然后将其定名为<code>a</code>到<code>i</code>的九个区域，分别对应这九个单元格。</p><p>多个单元格合并成一个区域的写法如下。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-areas: 'a a a'<br>                     'b b b'<br>                     'c c c';<br></code></pre></td></tr></table></figure></blockquote><p>上面代码将9个单元格分成<code>a</code>、<code>b</code>、<code>c</code>三个区域。</p><p>下面是一个布局实例。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-template-areas</span>: "<span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">header</span> <span class="hljs-selector-tag">header</span>"<br>                     "<span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">main</span> <span class="hljs-selector-tag">sidebar</span>"<br>                     "<span class="hljs-selector-tag">footer</span> <span class="hljs-selector-tag">footer</span> <span class="hljs-selector-tag">footer</span>";<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，顶部是页眉区域<code>header</code>，底部是页脚区域<code>footer</code>，中间部分则为<code>main</code>和<code>sidebar</code>。</p><p>如果某些区域不需要利用，则使用”点”（<code>.</code>）表示。</p><blockquote><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">grid-template-areas: 'a . c'<br>                     'd . f'<br>                     'g . i';<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。</p><blockquote><p>注意，区域的命名会影响到网格线。每个区域的起始网格线，会自动命名为<code>区域名-start</code>，终止网格线自动命名为<code>区域名-end</code>。</p><p>比如，区域名为<code>header</code>，则起始位置的水平网格线和垂直网格线叫做<code>header-start</code>，终止位置的水平网格线和垂直网格线叫做<code>header-end</code>。</p></blockquote><h3 id="3-5-grid-auto-flow-属性"><a href="#3-5-grid-auto-flow-属性" class="headerlink" title="3.5 grid-auto-flow 属性"></a>3.5 grid-auto-flow 属性</h3><p>划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是”先行后列”，即先填满第一行，再开始放入第二行，即下图数字的顺序。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032506.png" srcset="/img/loading.gif" alt="img"></p><p>这个顺序由<code>grid-auto-flow</code>属性决定，默认值是<code>row</code>，即”先行后列”。也可以将它设成<code>column</code>，变成”先列后行”。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-auto-flow</span>: <span class="hljs-selector-tag">column</span>;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/xutokec/edit?css,output" target="_blank" rel="noopener">上面代码</a>设置了<code>column</code>以后，放置顺序就变成了下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032512.png" srcset="/img/loading.gif" alt="img"></p><p><code>grid-auto-flow</code>属性除了设置成<code>row</code>和<code>column</code>，还可以设成<code>row dense</code>和<code>column dense</code>。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。</p><p><a href="https://jsbin.com/wapejok/edit?css,output" target="_blank" rel="noopener">下面的例子</a>让1号项目和2号项目各占据两个单元格，然后在默认的<code>grid-auto-flow: row</code>情况下，会产生下面这样的布局。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032513.png" srcset="/img/loading.gif" alt="img"></p><p>上图中，1号项目后面的位置是空的，这是因为3号项目默认跟着2号项目，所以会排在2号项目后面。</p><p>现在修改设置，设为<code>row dense</code>，表示”先行后列”，并且尽可能紧密填满，尽量不出现空格。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-auto-flow</span>: <span class="hljs-selector-tag">row</span> <span class="hljs-selector-tag">dense</span>;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/helewuy/edit?css,output" target="_blank" rel="noopener">上面代码</a>的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032514.png" srcset="/img/loading.gif" alt="img"></p><p>上图会先填满第一行，再填满第二行，所以3号项目就会紧跟在1号项目的后面。8号项目和9号项目就会排到第四行。</p><p>如果将设置改为<code>column dense</code>，表示”先列后行”，并且尽量填满空格。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">grid-auto-flow</span>: <span class="hljs-selector-tag">column</span> <span class="hljs-selector-tag">dense</span>;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/pupoduc/1/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>的效果如下。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032515.png" srcset="/img/loading.gif" alt="img"></p><p>上图会先填满第一列，再填满第2列，所以3号项目在第一列，4号项目在第二列。8号项目和9号项目被挤到了第四列。</p><h3 id="3-6-justify-items-属性，-align-items-属性，-place-items-属性"><a href="#3-6-justify-items-属性，-align-items-属性，-place-items-属性" class="headerlink" title="3.6 justify-items 属性， align-items 属性， place-items 属性"></a>3.6 justify-items 属性， align-items 属性， place-items 属性</h3><p><code>justify-items</code>属性设置单元格内容的水平位置（左中右），<code>align-items</code>属性设置单元格内容的垂直位置（上中下）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-items</span>: start | end | center | stretch;<br>  <span class="hljs-attribute">align-items</span>: start | end | center | stretch;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>这两个属性的写法完全相同，都可以取下面这些值。</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/gijeqej/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示，单元格的内容左对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032516.png" srcset="/img/loading.gif" alt="img"></p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">align-items</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/tecawur/edit?css,output" target="_blank" rel="noopener">上面代码</a>表示，单元格的内容头部对齐，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032517.png" srcset="/img/loading.gif" alt="img"></p><p><code>place-items</code>属性是<code>align-items</code>属性和<code>justify-items</code>属性的合并简写形式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-items</span>: &lt;<span class="hljs-selector-tag">align-items</span>&gt; &lt;<span class="hljs-selector-tag">justify-items</span>&gt;;<br></code></pre></td></tr></table></figure></blockquote><p>下面是一个例子。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-items</span>: <span class="hljs-selector-tag">start</span> <span class="hljs-selector-tag">end</span>;<br></code></pre></td></tr></table></figure></blockquote><p>如果省略第二个值，则浏览器认为与第一个值相等。</p><h3 id="3-7-justify-content-属性，-align-content-属性，-place-content-属性"><a href="#3-7-justify-content-属性，-align-content-属性，-place-content-属性" class="headerlink" title="3.7 justify-content 属性， align-content 属性， place-content 属性"></a>3.7 justify-content 属性， align-content 属性， place-content 属性</h3><p><code>justify-content</code>属性是整个内容区域在容器里面的水平位置（左中右），<code>align-content</code>属性是整个内容区域的垂直位置（上中下）。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">justify-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;<br>  <span class="hljs-attribute">align-content</span>: start | end | center | stretch | space-around | space-between | space-evenly;  <br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>这两个属性的写法完全相同，都可以取下面这些值。（下面的图都以<code>justify-content</code>属性为例，<code>align-content</code>属性的图完全一样，只是将水平方向改成垂直方向。）</p><blockquote><ul><li>start - 对齐容器的起始边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032519.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>end - 对齐容器的结束边框。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032518.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>center - 容器内部居中。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032520.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>stretch - 项目大小没有指定时，拉伸占据整个网格容器。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032521.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>space-around - 每个项目两侧的间隔相等。所以，项目之间的间隔比项目与容器边框的间隔大一倍。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032522.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>space-between - 项目与项目的间隔相等，项目与容器边框之间没有间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032523.png" srcset="/img/loading.gif" alt="img"></p><blockquote><ul><li>space-evenly - 项目与项目的间隔相等，项目与容器边框之间也是同样长度的间隔。</li></ul></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032524.png" srcset="/img/loading.gif" alt="img"></p><p><code>place-content</code>属性是<code>align-content</code>属性和<code>justify-content</code>属性的合并简写形式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-content</span>: &lt;<span class="hljs-selector-tag">align-content</span>&gt; &lt;<span class="hljs-selector-tag">justify-content</span>&gt;<br></code></pre></td></tr></table></figure></blockquote><p>下面是一个例子。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-content</span>: <span class="hljs-selector-tag">space-around</span> <span class="hljs-selector-tag">space-evenly</span>;<br></code></pre></td></tr></table></figure></blockquote><p>如果省略第二个值，浏览器就会假定第二个值等于第一个值。</p><h3 id="3-8-grid-auto-columns-属性，-grid-auto-rows-属性"><a href="#3-8-grid-auto-columns-属性，-grid-auto-rows-属性" class="headerlink" title="3.8 grid-auto-columns 属性， grid-auto-rows 属性"></a>3.8 grid-auto-columns 属性， grid-auto-rows 属性</h3><p>有时候，一些项目的指定位置，在现有网格的外部。比如网格只有3列，但是某一个项目指定在第5行。这时，浏览器会自动生成多余的网格，以便放置项目。</p><p><code>grid-auto-columns</code>属性和<code>grid-auto-rows</code>属性用来设置，浏览器自动创建的多余网格的列宽和行高。它们的写法与<code>grid-template-columns</code>和<code>grid-template-rows</code>完全相同。如果不指定这两个属性，浏览器完全根据单元格内容的大小，决定新增网格的列宽和行高。</p><p><a href="https://jsbin.com/sayuric/edit?css,output" target="_blank" rel="noopener">下面的例子</a>里面，划分好的网格是3行 x 3列，但是，8号项目指定在第4行，9号项目指定在第5行。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span> &#123;<br>  <span class="hljs-attribute">display</span>: grid;<br>  <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">100px</span> <span class="hljs-number">100px</span> <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">grid-auto-rows</span>: <span class="hljs-number">50px</span>; <br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码指定新增的行高统一为50px（原始的行高为100px）。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032525.png" srcset="/img/loading.gif" alt="img"></p><h3 id="3-9-grid-template-属性，-grid-属性"><a href="#3-9-grid-template-属性，-grid-属性" class="headerlink" title="3.9 grid-template 属性， grid 属性"></a>3.9 grid-template 属性， grid 属性</h3><p><code>grid-template</code>属性是<code>grid-template-columns</code>、<code>grid-template-rows</code>和<code>grid-template-areas</code>这三个属性的合并简写形式。</p><p><code>grid</code>属性是<code>grid-template-rows</code>、<code>grid-template-columns</code>、<code>grid-template-areas</code>、 <code>grid-auto-rows</code>、<code>grid-auto-columns</code>、<code>grid-auto-flow</code>这六个属性的合并简写形式。</p><p>从易读易写的角度考虑，还是建议不要合并属性，所以这里就不详细介绍这两个属性了。</p><h2 id="四、项目属性"><a href="#四、项目属性" class="headerlink" title="四、项目属性"></a>四、项目属性</h2><p>下面这些属性定义在项目上面。</p><h3 id="4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性"><a href="#4-1-grid-column-start-属性，-grid-column-end-属性，-grid-row-start-属性，-grid-row-end-属性" class="headerlink" title="4.1 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性"></a>4.1 grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性</h3><p>项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。</p><blockquote><ul><li><code>grid-column-start</code>属性：左边框所在的垂直网格线</li><li><code>grid-column-end</code>属性：右边框所在的垂直网格线</li><li><code>grid-row-start</code>属性：上边框所在的水平网格线</li><li><code>grid-row-end</code>属性：下边框所在的水平网格线</li></ul></blockquote><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/yukobuf/edit?css,output" target="_blank" rel="noopener">上面代码</a>指定，1号项目的左边框是第二根垂直网格线，右边框是第四根垂直网格线。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032526.png" srcset="/img/loading.gif" alt="img"></p><p>上图中，只指定了1号项目的左右边框，没有指定上下边框，所以会采用默认位置，即上边框是第一根水平网格线，下边框是第二根水平网格线。</p><p>除了1号项目以外，其他项目都没有指定位置，由浏览器自动布局，这时它们的位置由容器的<code>grid-auto-flow</code>属性决定，这个属性的默认值是<code>row</code>，因此会”先行后列”进行排列。读者可以把这个属性的值分别改成<code>column</code>、<code>row dense</code>和<code>column dense</code>，看看其他项目的位置发生了怎样的变化。</p><p><a href="https://jsbin.com/nagobey/edit?html,css,output" target="_blank" rel="noopener">下面的例子</a>是指定四个边框位置的效果。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">4</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032527.png" srcset="/img/loading.gif" alt="img"></p><p>这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: header-start;<br>  <span class="hljs-attribute">grid-column-end</span>: header-end;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，左边框和右边框的位置，都指定为网格线的名字。</p><p>这四个属性的值还可以使用<code>span</code>关键字，表示”跨越”，即左右边框（上下边框）之间跨越多少个网格。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/hehumay/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>表示，1号项目的左边框距离右边框跨越2个网格。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032528.png" srcset="/img/loading.gif" alt="img"></p><p>这与<a href="https://jsbin.com/mujihib/edit?html,css,output" target="_blank" rel="noopener">下面的代码</a>效果完全一样。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-end</span>: span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>使用这四个属性，如果产生了项目的重叠，则使用<code>z-index</code>属性指定项目的重叠顺序。</p><h3 id="4-2-grid-column-属性，-grid-row-属性"><a href="#4-2-grid-column-属性，-grid-row-属性" class="headerlink" title="4.2 grid-column 属性， grid-row 属性"></a>4.2 grid-column 属性， grid-row 属性</h3><p><code>grid-column</code>属性是<code>grid-column-start</code>和<code>grid-column-end</code>的合并简写形式，<code>grid-row</code>属性是<code>grid-row-start</code>属性和<code>grid-row-end</code>的合并简写形式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>:  / ;<br>  <span class="hljs-attribute">grid-row</span>:  / ;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>下面是一个例子。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column-start</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-column-end</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row-start</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row-end</span>: <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，项目<code>item-1</code>占据第一行，从第一根列线到第三根列线。</p><p>这两个属性之中，也可以使用<code>span</code>关键字，表示跨越多少个网格。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / <span class="hljs-number">3</span>;<br>&#125;<br><span class="hljs-comment">/* 等同于 */</span><br><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-number">#b03532</span>;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span> / span <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/volugow/edit?html,css,output" target="_blank" rel="noopener">上面代码</a>中，项目<code>item-1</code>占据的区域，包括第一行 + 第二行、第一列 + 第二列。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032529.png" srcset="/img/loading.gif" alt="img"></p><p>斜杠以及后面的部分可以省略，默认跨越一个网格。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-column</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">grid-row</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>上面代码中，项目<code>item-1</code>占据左上角第一个网格。</p><h3 id="4-3-grid-area-属性"><a href="#4-3-grid-area-属性" class="headerlink" title="4.3 grid-area 属性"></a>4.3 grid-area 属性</h3><p><code>grid-area</code>属性指定项目放在哪一个区域。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: e;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><a href="https://jsbin.com/qokexob/edit?css,output" target="_blank" rel="noopener">上面代码</a>中，1号项目位于<code>e</code>区域，效果如下图。</p><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032530.png" srcset="/img/loading.gif" alt="img"></p><p><code>grid-area</code>属性还可用作<code>grid-row-start</code>、<code>grid-column-start</code>、<code>grid-row-end</code>、<code>grid-column-end</code>的合并简写形式，直接指定项目的位置。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>下面是一个<a href="https://jsbin.com/duyafez/edit?css,output" target="_blank" rel="noopener">例子</a>。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span> &#123;<br>  <span class="hljs-attribute">grid-area</span>: <span class="hljs-number">1</span> / <span class="hljs-number">1</span> / <span class="hljs-number">3</span> / <span class="hljs-number">3</span>;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><h3 id="4-4-justify-self-属性，-align-self-属性，-place-self-属性"><a href="#4-4-justify-self-属性，-align-self-属性，-place-self-属性" class="headerlink" title="4.4 justify-self 属性， align-self 属性， place-self 属性"></a>4.4 justify-self 属性， align-self 属性， place-self 属性</h3><p><code>justify-self</code>属性设置单元格内容的水平位置（左中右），跟<code>justify-items</code>属性的用法完全一致，但只作用于单个项目。</p><p><code>align-self</code>属性设置单元格内容的垂直位置（上中下），跟<code>align-items</code>属性的用法完全一致，也是只作用于单个项目。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;<br>  <span class="hljs-attribute">justify-self</span>: start | end | center | stretch;<br>  <span class="hljs-attribute">align-self</span>: start | end | center | stretch;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p>这两个属性都可以取下面四个值。</p><blockquote><ul><li>start：对齐单元格的起始边缘。</li><li>end：对齐单元格的结束边缘。</li><li>center：单元格内部居中。</li><li>stretch：拉伸，占满单元格的整个宽度（默认值）。</li></ul></blockquote><p>下面是<code>justify-self: start</code>的例子。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.item-1</span>  &#123;<br>  <span class="hljs-attribute">justify-self</span>: start;<br>&#125;<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://www.wangbase.com/blogimg/asset/201903/bg2019032532.png" srcset="/img/loading.gif" alt="img"></p><p><code>place-self</code>属性是<code>align-self</code>属性和<code>justify-self</code>属性的合并简写形式。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-self</span>: &lt;<span class="hljs-selector-tag">align-self</span>&gt; &lt;<span class="hljs-selector-tag">justify-self</span>&gt;;<br></code></pre></td></tr></table></figure></blockquote><p>下面是一个例子。</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">place-self</span>: <span class="hljs-selector-tag">center</span> <span class="hljs-selector-tag">center</span>;<br></code></pre></td></tr></table></figure></blockquote><p>如果省略第二个值，<code>place-self</code>属性会认为这两个值相等。</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>Css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML</title>
    <link href="/2018/09/12/HTML/"/>
    <url>/2018/09/12/HTML/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><p>标签的学习</p><h3 id="块级标签"><a href="#块级标签" class="headerlink" title="块级标签"></a>块级标签</h3><ul><li>div</li><li>p</li><li>h1-h6</li><li>ul</li><li>li</li></ul><h3 id="内联标签"><a href="#内联标签" class="headerlink" title="内联标签"></a>内联标签</h3><ul><li>span</li><li>a</li></ul><h3 id="小样例"><a href="#小样例" class="headerlink" title="小样例"></a>小样例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!--html 5 文档声明（语义化） --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">"en"</span>&gt;</span><br><span class="hljs-comment">&lt;!--括号 标记语言 通常成对出现 单标签也要闭合  --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 包含的标记是页面的标题、序言、说明等内容，它本身不作为内容来显示，但影响网页显示的效果 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"UTF-8"</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 浏览器必须知道使用何种字符集。</span><br><span class="hljs-comment">                            -- ASCII HTML4 8字节</span><br><span class="hljs-comment">                            -- GBK,GB2312(汉字字符编码)  Big5（繁体字）</span><br><span class="hljs-comment">                            -- UTF-8 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"keywords"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"html基础标签"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">"X-UA-Compatible"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"ie=edge"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"icon"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"../day-1/img/favicon.ico"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./HelloWord.css"</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>How To Make L<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">meta</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>&gt;<br><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"#kkk"</span>&gt;</span>kkk<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>jjjjj<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>kkkk<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>This is a heading<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is paragraph<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>this is span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>another this is span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>This is ul-&gt;li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>This is ul-&gt;li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>this is ul-&gt;li-&gt;ul<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>this is ul-&gt;li-&gt;ul<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>this is ul-&gt;li-&gt;ul<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">ol</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>This is Ol-&gt;li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>This is Ol-&gt;li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>This is Ol-&gt;li<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"./test.html#lll"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'kkk'</span> <span class="hljs-attr">target</span>=<span class="hljs-string">"_blank"</span>&gt;</span>百度一下，你就知道<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">"MAILTO:747097149@qq.com"</span> <span class="hljs-attr">method</span>=<span class="hljs-string">"post"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">fieldset</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">legend</span>&gt;</span>登录<span class="hljs-tag">&lt;/<span class="hljs-name">legend</span>&gt;</span><br>                账号：<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>                 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"count"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>                密码:<span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"password"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">""</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">fieldset</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Select</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"province"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"north"</span>&gt;</span>黑龙江<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"north"</span>&gt;</span>吉林<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"north"</span>&gt;</span>辽宁<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"south"</span> <span class="hljs-attr">selected</span>&gt;</span>广东<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"south"</span>&gt;</span>江西<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">Select</span>&gt;</span> 省<span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">list</span>=<span class="hljs-string">"browsers"</span> <span class="hljs-attr">autocomplete</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">datalist</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"browsers"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Internet Explorer"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Firefox"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Chrome"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Opera"</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">option</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Safari"</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">datalist</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>            backetball:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"habbit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"backetball"</span>&gt;</span><br>            bamin:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"habbit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"bamin"</span>&gt;</span><br>            table:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"checkbox"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"habbit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"table"</span>&gt;</span><br><br>            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>            man:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"man"</span>&gt;</span><br>            woman:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"woman"</span>&gt;</span><br>            mid:<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"radio"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"sex"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"mid"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"submit"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"Submit"</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>opop<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">button</span>&gt;</span>lllll<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../img/person.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"wrong!!"</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../img/a.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">article</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">header</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>This is an article<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">section</span>&gt;</span><br>            reader reviews<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">article</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>流内容（图片图表代码） <span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>例如：<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"../img/dufu.jpg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span><br>                coding...<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>效果可复制进ide查看</em></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
      <tag>HTML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端</title>
    <link href="/2018/09/11/%E5%89%8D%E7%AB%AF/"/>
    <url>/2018/09/11/%E5%89%8D%E7%AB%AF/</url>
    
    <content type="html"><![CDATA[<h1 id="前端入门"><a href="#前端入门" class="headerlink" title="前端入门"></a>前端入门</h1><p>​       前端开发是创建Web页面或app等前端界面呈现给用户的过程，通过HTML，CSS，JavaScript以及衍生出来的各种技术、框架、解决方案，来实现互联网产品的用户界面交互 [1] 。它从网页制作演变而来，名称上有很明显的时代特征。在互联网的演化进程中，网页制作是Web1.0]时代的产物，早期网站主要内容都是静态，以图片和文字为主，用户使用网站的行为也以浏览为主。随着互联网技术的发展，现代网页更加美观，交互效果显著，功能更加强大。</p><h2 id="主要技术"><a href="#主要技术" class="headerlink" title="主要技术"></a>主要技术</h2><p><a href="https://www.w3school.com.cn/html/index.asp" target="_blank" rel="noopener">HTML</a>、<a href="https://www.w3school.com.cn/css/index.asp" target="_blank" rel="noopener">CSS</a>、<a href="[https://baike.baidu.com/item/JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/10576650?fr=aladdin](https://baike.baidu.com/item/JavaScript高级程序设计/10576650?fr=aladdin)">JavaScript</a></p><p><a href="https://reactjs.org/" target="_blank" rel="noopener">React</a>、<a href="https://cn.vuejs.org/" target="_blank" rel="noopener">Vue</a></p><h2 id="学习路线"><a href="#学习路线" class="headerlink" title="学习路线"></a>学习路线</h2><p><img src="http://s1.wailian.download/2020/01/11/9220068f8d90e41a141680ab174a5976.png" srcset="/img/loading.gif" alt="基础前端学习路线图"></p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
